<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>多线程的实现方式 | Ammar's Blog</title><meta name="description" content="多线程的实现方式"><meta name="keywords" content="iOS"><meta name="author" content="Ammar"><meta name="copyright" content="Ammar"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.11.1/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="http://lizhaoloveit.cn/2015/03/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="多线程的实现方式"><meta name="twitter:description" content="多线程的实现方式"><meta name="twitter:image" content="https://lizhaoloveit.cn/blogimages/blog/avatar.jpg"><meta property="og:type" content="article"><meta property="og:title" content="多线程的实现方式"><meta property="og:url" content="http://lizhaoloveit.cn/2015/03/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"><meta property="og:site_name" content="Ammar's Blog"><meta property="og:description" content="多线程的实现方式"><meta property="og:image" content="https://lizhaoloveit.cn/blogimages/blog/avatar.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="prev" title="抽屉效果框架" href="http://lizhaoloveit.cn/2015/04/06/%E6%8A%BD%E5%B1%89%E6%95%88%E6%9E%9C%E6%A1%86%E6%9E%B6/"><link rel="next" title="多线程基本概念" href="http://lizhaoloveit.cn/2015/03/05/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?162506e75ffd64287398566b2f5738c8";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"VRMKRAV9AT","apiKey":"bd7157400046d0f02396708a501a3480","indexName":"lizhaoloveit","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"cookieDomain":"https://lizhaoloveit.cn/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: '添加书签',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天'

  
}</script><meta name="generator" content="Hexo 4.2.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#pthread-实现多线程操作"><span class="toc-number">1.</span> <span class="toc-text">pthread 实现多线程操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NSThread实现多线程"><span class="toc-number">2.</span> <span class="toc-text">NSThread实现多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建线程的多种方式"><span class="toc-number">2.1.</span> <span class="toc-text">创建线程的多种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程间通信"><span class="toc-number">2.2.</span> <span class="toc-text">线程间通信</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GCD-实现多线程"><span class="toc-number">3.</span> <span class="toc-text">GCD 实现多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GCD-简介"><span class="toc-number">3.1.</span> <span class="toc-text">GCD 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#任务和队列"><span class="toc-number">3.2.</span> <span class="toc-text">任务和队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#同步函数和异步函数，并发队列和串行队列"><span class="toc-number">3.3.</span> <span class="toc-text">同步函数和异步函数，并发队列和串行队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GCD实现线程通信"><span class="toc-number">3.4.</span> <span class="toc-text">GCD实现线程通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GCD其他常用函数"><span class="toc-number">3.5.</span> <span class="toc-text">GCD其他常用函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#dispatch-barrier-栅栏"><span class="toc-number">3.5.1.</span> <span class="toc-text">dispatch_barrier 栅栏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dispatch-after-延迟执行"><span class="toc-number">3.5.2.</span> <span class="toc-text">dispatch_after 延迟执行</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dispatch-apply-快速迭代"><span class="toc-number">3.6.</span> <span class="toc-text">dispatch_apply 快速迭代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dispatch-group-队列组"><span class="toc-number">3.7.</span> <span class="toc-text">dispatch_group 队列组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GCD定时器"><span class="toc-number">3.8.</span> <span class="toc-text">GCD定时器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NSOperation实现多线程"><span class="toc-number">4.</span> <span class="toc-text">NSOperation实现多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#NSInvocationOperation"><span class="toc-number">4.1.</span> <span class="toc-text">NSInvocationOperation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NSBlockOperation"><span class="toc-number">4.2.</span> <span class="toc-text">NSBlockOperation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NSOperationQueue"><span class="toc-number">4.3.</span> <span class="toc-text">NSOperationQueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#队列的取消、暂停、恢复："><span class="toc-number">4.4.</span> <span class="toc-text">队列的取消、暂停、恢复：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#添加依赖"><span class="toc-number">4.5.</span> <span class="toc-text">添加依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程间通信-1"><span class="toc-number">4.6.</span> <span class="toc-text">线程间通信</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#应用"><span class="toc-number">5.</span> <span class="toc-text">应用</span></a></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://lizhaoloveit.cn/blogimages/blog/top_img.jpg)"><div id="page-header"><span class="pull-left"> <a class="blog_title" id="site-name" href="/">Ammar's Blog</a></span><div class="open toggle-menu pull-right"><div class="menu-icon-first"></div><div class="menu-icon-second"></div><div class="menu-icon-third"></div></div><span class="pull-right menus"><div class="mobile_author_icon"><img class="lozad" data-src="https://lizhaoloveit.cn/blogimages/blog/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'"><div class="mobile_author-info__description">微信号：aicjaish</div></div><hr><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a><a class="site-page" href="/comment/"><i class="fa-fw fa fa-coffee"></i><span> 留言</span></a><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title"><div class="posttitle">多线程的实现方式</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2015-03-06<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2019-07-29</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/iOS/">iOS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/iOS/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></span><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">3.5k</span><span class="post-meta__separator">|</span><span>阅读时长: 14 分钟</span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><p>iOS中实现多线程的技术方案</p>
<h2 id="pthread-实现多线程操作"><a href="#pthread-实现多线程操作" class="headerlink" title="pthread 实现多线程操作"></a>pthread 实现多线程操作</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">代码实现：</span><br><span class="line"><span class="keyword">void</span> * run(<span class="keyword">void</span> *param)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"---buttonclick---%zd---%@"</span>, i, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)clickButton:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    <span class="comment">// 定义一个线程</span></span><br><span class="line">    pthread_t thread;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个线程  (参1)pthread_t *restrict:创建线程的指针，(参2)const pthread_attr_t *restrict:线程属性  (参3)void *(*)(void *):线程执行的函数的指针，(参4)void *restrict:null</span></span><br><span class="line">    pthread_create(&amp;thread, <span class="literal">NULL</span>, run, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 何时回收线程不需要你考虑</span></span><br><span class="line">    pthread_t thread2;</span><br><span class="line">    </span><br><span class="line">    pthread_create(&amp;thread2, <span class="literal">NULL</span>, run, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="NSThread实现多线程"><a href="#NSThread实现多线程" class="headerlink" title="NSThread实现多线程"></a>NSThread实现多线程</h2><p>一个 NSThread 对象就代表一条线程</p>
<h3 id="创建线程的多种方式"><a href="#创建线程的多种方式" class="headerlink" title="创建线程的多种方式"></a>创建线程的多种方式</h3><ul>
<li>第一种方式：先创建再启动线程        </li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建线程</span></span><br><span class="line"><span class="built_in">NSThread</span> *thread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run:) object:<span class="string">@"jack"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程启动了，事情做完了才会死， 一个NSThread对象就代表一条线程</span></span><br><span class="line">[thread start];</span><br></pre></td></tr></table></figure>

<ul>
<li>第二种：直接创建并启动线程</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接创建并启动线程</span></span><br><span class="line">[<span class="built_in">NSThread</span> detachNewThreadSelector:<span class="keyword">@selector</span>(run:) toTarget:<span class="keyword">self</span> withObject:<span class="string">@"jack"</span>];</span><br></pre></td></tr></table></figure>
<ul>
<li>第三种：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接创建并启动线程</span></span><br><span class="line">[<span class="keyword">self</span> performSelectorInBackground:<span class="keyword">@selector</span>(run:) withObject:<span class="string">@"jack"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使线程进入阻塞状态</span></span><br><span class="line">[<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2.0</span>];</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - 执行run方法</span></span><br><span class="line">- (<span class="keyword">void</span>)run:(<span class="built_in">NSString</span> *)param</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 当前线程是否是主线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"---%@---%zd---%d"</span>, [<span class="built_in">NSThread</span> currentThread], i,  [<span class="built_in">NSThread</span> isMainThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>方法2和方法3的优点:快捷    方法1的优点:可以轻松拿到线程</p>
</blockquote>
<h3 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h3><ul>
<li>线程间通信的体现<ul>
<li>1个线程传递数据给另1个线程</li>
<li>在1个线程中执行完特定任务后，转到另1个线程继续执行任务</li>
</ul>
</li>
</ul>
<p>线程间通信的常用方法：小程序图片下载</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取图片的url</span></span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://7xjanq.com1.z0.glb.clouddn.com/6478.jpg"</span>];</span><br><span class="line"><span class="comment">// 另开1条线程 object用于数据的传递</span></span><br><span class="line">    <span class="built_in">NSThread</span> *thread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(downLoadWithURL:) object:url];</span><br><span class="line">    <span class="comment">// 由于下面下载图片的耗时太长，应领开启线程来完成</span></span><br><span class="line">    [thread start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下载图片</span></span><br><span class="line">- (<span class="keyword">void</span>)downLoadWithURL:(<span class="built_in">NSURL</span> *)url</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    <span class="comment">// 下载图片</span></span><br><span class="line">    <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:url];</span><br><span class="line">    <span class="comment">// 生成图片</span></span><br><span class="line">    <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithData:data];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回主线程显示图片</span></span><br><span class="line">    [<span class="keyword">self</span>.imageView performSelectorOnMainThread:<span class="keyword">@selector</span>(setImage:) withObject:image waitUntilDone:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上两种方式使用线程已经过时了，开发中我们操作线程大多都使用 GCD 和 NSOperation 来实现多线程操作。</p>
<p>下面我就给大家系统的介绍一下 GCD 是如何实现多线程的</p>
<h2 id="GCD-实现多线程"><a href="#GCD-实现多线程" class="headerlink" title="GCD 实现多线程"></a>GCD 实现多线程</h2><h3 id="GCD-简介"><a href="#GCD-简介" class="headerlink" title="GCD 简介"></a>GCD 简介</h3><p>GCD 全称是Grand Central Dispatch，可译为“超级厉害的中枢调度器”，GCD 是苹果公司为多核的并行运算提出的解决方案， GCD会自动利用更多的 CPU 内核（比如双核、四核）来开启线程执行任务，GCD 会自动管理线程的生命周期（创建线程、调度任务、销毁线程），不需要我们程序员手动管理内存。</p>
<h3 id="任务和队列"><a href="#任务和队列" class="headerlink" title="任务和队列"></a>任务和队列</h3><p>任务：在同步函数和异步函数中执行<br>队列：用来存放任务（并发 串行）</p>
<p>GCD会自动将队列中的任务取出，放到对应的线程，任务的取出遵循FIFO，即先入先出队列，First Input First Output 的缩写。先进入的任务先完成并结束，再执行后面的任务。</p>
<h3 id="同步函数和异步函数，并发队列和串行队列"><a href="#同步函数和异步函数，并发队列和串行队列" class="headerlink" title="同步函数和异步函数，并发队列和串行队列"></a>同步函数和异步函数，并发队列和串行队列</h3><ul>
<li><p>用同步的方式执行任务：在当前线程中可立即执行任务，不具备开启线程的能力</p>
</li>
<li><p>用异步的方式执行任务：在当前线程结束时执行任务，具备开启新的线程的能力</p>
</li>
<li><p>并发队列：允许多个任务同时执行</p>
</li>
<li><p>串行队列：一个任务执行完毕后，再执行下一个任务</p>
</li>
</ul>
<p>创建并发/串行队列代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建并发队列 </span></span><br><span class="line"><span class="comment">// 参1:const char *label 队列名称 </span></span><br><span class="line"><span class="comment">// 参2:dispatch_queue_attr_t attr 队列类型</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queueConcurrent = dispatch_queue_create(<span class="string">"520it.com"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 创建串行队列  serial 串行  concurrent并发</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queueSerial = dispatch_queue_create(<span class="string">"520it.com"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 获取全局队列 全局队列是并发队列 </span></span><br><span class="line"><span class="comment">// 参1:队列的优先级 </span></span><br><span class="line"><span class="comment">// 参2:0(以后可能用到的参数)</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queueGlobal = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 全局并发队列的优先级</span></span><br><span class="line"><span class="meta">#define DISPATCH_QUEUE_PRIORITY_HIGH 2 // 高</span></span><br><span class="line"><span class="meta">#define DISPATCH_QUEUE_PRIORITY_DEFAULT 0 // 默认（中）</span></span><br><span class="line"><span class="meta">#define DISPATCH_QUEUE_PRIORITY_LOW (-2) // 低</span></span><br><span class="line"><span class="meta">#define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN // 后台</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 获取主队列  在主队列中的任务都会在主线程中执行。</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queueMain = dispatch_get_main_queue();</span><br></pre></td></tr></table></figure>

<p>同步/异步函数代码表示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// GCD同步函数串行队列(立即执行，当前线程) </span></span><br><span class="line"><span class="comment">// 参1: dispatch_queue_t queue 队列 </span></span><br><span class="line"><span class="comment">// 参2: 任务</span></span><br><span class="line"><span class="built_in">dispatch_sync</span>(queueSerial, ^&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">NSLog</span>(<span class="string">@"~~~%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 同步函数并行队列(立即执行，当前线程)</span></span><br><span class="line"><span class="built_in">dispatch_sync</span>(queueConcurrent, ^&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">NSLog</span>(<span class="string">@"~~~%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 异步函数串行队列 (另开线程，多个任务按顺序执行)</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(queueSerial, ^&#123;</span><br><span class="line">	<span class="built_in">dispatch_async</span>(queueSerial, ^&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			<span class="built_in">NSLog</span>(<span class="string">@"~~~%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	<span class="built_in">dispatch_async</span>(queueSerial, ^&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			<span class="built_in">NSLog</span>(<span class="string">@"~~~%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	<span class="built_in">dispatch_async</span>(queueSerial, ^&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			<span class="built_in">NSLog</span>(<span class="string">@"~~~%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 异步函数并行队列 (另开线程，多个任务一起执行)</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(queueConcurrent, ^&#123;</span><br><span class="line">	<span class="built_in">dispatch_async</span>(queueSerial, ^&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">				<span class="built_in">NSLog</span>(<span class="string">@"~~~%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	<span class="built_in">dispatch_async</span>(queueSerial, ^&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			<span class="built_in">NSLog</span>(<span class="string">@"~~~%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	<span class="built_in">dispatch_async</span>(queueSerial, ^&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			<span class="built_in">NSLog</span>(<span class="string">@"~~~%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 主队列:(任何一个任务只要在主队列中，都会加入到主线程的队列中执行)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意<br>使用sync函数(同步函数)往当前串行队列中添加任务，会卡住当前的串行队列</p>
</blockquote>
<p><strong>解释：使用同步函数添加任务 A 到串行队列，说明要在当前串行队列立即执行任务 A ，任务 A 执行完后，才会执行任务 A 后面的代码。但当前队列是串行队列，也就是说任务 A 必须等到当前串行队列中正在执行的任务 B 完成之后才能执行，因此又必须先执行任务 A 中立即执行任务，又要必须等到任务 B 执行完以后才能执行下一个任务，所以就会卡死。你等我，我等你，谁也无法执行。</strong></p>
<h3 id="GCD实现线程通信"><a href="#GCD实现线程通信" class="headerlink" title="GCD实现线程通信"></a>GCD实现线程通信</h3><p>小项目：下载图片</p>
<p>代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取图片的url</span></span><br><span class="line"><span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://7xjanq.com1.z0.glb.clouddn.com/6478.jpg"</span>];</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 开启线程下载图片</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"111"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">	<span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:url];</span><br><span class="line">	<span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithData:data];</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 下载完成后返回主线程显示图片</span></span><br><span class="line">	<span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">		<span class="keyword">self</span>.imageView.image = image;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="GCD其他常用函数"><a href="#GCD其他常用函数" class="headerlink" title="GCD其他常用函数"></a>GCD其他常用函数</h3><h4 id="dispatch-barrier-栅栏"><a href="#dispatch-barrier-栅栏" class="headerlink" title="dispatch_barrier 栅栏"></a>dispatch_barrier 栅栏</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.barrier : 在barrier前面的先执行，然后再执行barrier，然后再执行barrier后面的 barrier的queue不能是全局的并发队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"11"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;  i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">NSLog</span>(<span class="string">@"%@--1"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;  i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">NSLog</span>(<span class="string">@"%@--2"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line">dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;  i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">NSLog</span>(<span class="string">@"%@--3"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;  i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">NSLog</span>(<span class="string">@"%@--4"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="dispatch-after-延迟执行"><a href="#dispatch-after-延迟执行" class="headerlink" title="dispatch_after 延迟执行"></a>dispatch_after 延迟执行</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 延迟执行</span></span><br><span class="line"><span class="comment">// 方法1</span></span><br><span class="line">[<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(run:) withObject:<span class="string">@"参数"</span> afterDelay:<span class="number">2.0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2</span></span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2.0</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法3</span></span><br><span class="line">[<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">2.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run) userInfo:<span class="literal">nil</span> repeats:<span class="literal">NO</span>];</span><br><span class="line">```	</span><br><span class="line"></span><br><span class="line"><span class="meta">#### dispatch_once 整个程序运行中执行一次</span></span><br><span class="line"></span><br><span class="line">```objc</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整个程序中只执行一次</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">	<span class="comment">// 一次性代码</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>作用：实现某个类的单粒对象</p>
<blockquote>
<p>单例模式：在整个应用程序中，共享一份资源（这份资源只需要创建初始化1次）</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> _person;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)sharePerson</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        _person = [[<span class="keyword">super</span> alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> _person;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">+ (<span class="keyword">instancetype</span>)allocWithZone:(<span class="keyword">struct</span> _NSZone *)zone</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        _person = [<span class="keyword">super</span> allocWithZone:zone];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> _person;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">- (<span class="keyword">id</span>)<span class="keyword">copy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _person;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开发中一般自定义成宏，比较方便，一行代码搞定。</p>
<h3 id="dispatch-apply-快速迭代"><a href="#dispatch-apply-快速迭代" class="headerlink" title="dispatch_apply 快速迭代"></a>dispatch_apply 快速迭代</h3><p>示例小程序：将一个文件夹中的图片剪切到另一个文件夹</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 将图片剪切到另一个文件夹里</span></span><br><span class="line"><span class="built_in">NSString</span> *from = <span class="string">@"/Users/Ammar/Pictures/壁纸"</span>;</span><br><span class="line"><span class="built_in">NSString</span> *to = <span class="string">@"/Users/Ammar/Pictures/to"</span>;</span><br><span class="line"><span class="built_in">NSFileManager</span> *manager = [<span class="built_in">NSFileManager</span> defaultManager];</span><br><span class="line"><span class="built_in">NSArray</span> *subPaths = [manager subpathsAtPath:from];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速迭代</span></span><br><span class="line">dispatch_apply(subPaths.count, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^(size_t index) &#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"%@ - %zd"</span>, [<span class="built_in">NSThread</span> currentThread], index);</span><br><span class="line">	<span class="built_in">NSString</span> *subPath = subPaths[index];</span><br><span class="line">	<span class="built_in">NSString</span> *fromPath = [from stringByAppendingPathComponent:subPath];</span><br><span class="line">	<span class="built_in">NSString</span> *toPath = [to stringByAppendingPathComponent:subPath];</span><br><span class="line">        </span><br><span class="line">	<span class="comment">// 剪切</span></span><br><span class="line">	[manager moveItemAtPath:fromPath toPath:toPath error:<span class="literal">nil</span>];</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"%@---%zd"</span>, [<span class="built_in">NSThread</span> currentThread], index);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="dispatch-group-队列组"><a href="#dispatch-group-队列组" class="headerlink" title="dispatch_group 队列组"></a>dispatch_group 队列组</h3><p>示例小程序：需求下载图片1 下载图片2   将图片1和图片2合成新的图片</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 创建组</span></span><br><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 用组队列下载图片1</span></span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">	<span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://7xjanq.com1.z0.glb.clouddn.com/6478.jpg"</span>]];</span><br><span class="line">	<span class="keyword">self</span>.image1 = [<span class="built_in">UIImage</span> imageWithData:data];</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"1%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用组队列下载图片2</span></span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">	<span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://7xjanq.com1.z0.glb.clouddn.com/6478.jpg"</span>]];</span><br><span class="line">	<span class="keyword">self</span>.image2 = [<span class="built_in">UIImage</span> imageWithData:data];</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"2%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 将图片1和图片2合成一张图片</span></span><br><span class="line">dispatch_group_notify(group, queue, ^&#123;</span><br><span class="line">	<span class="built_in">CGFloat</span> imageW = <span class="keyword">self</span>.imageView.bounds.size.width;</span><br><span class="line">	<span class="built_in">CGFloat</span> imageH = <span class="keyword">self</span>.imageView.bounds.size.height;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 开启位图上下文</span></span><br><span class="line">	<span class="built_in">UIGraphicsBeginImageContext</span>(<span class="keyword">self</span>.imageView.bounds.size);</span><br><span class="line">        </span><br><span class="line">	<span class="comment">// 画图</span></span><br><span class="line">	[<span class="keyword">self</span>.image1 drawInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, imageW * <span class="number">0.5</span>, imageH)];</span><br><span class="line">	[<span class="keyword">self</span>.image2 drawInRect:<span class="built_in">CGRectMake</span>(imageW * <span class="number">0.5</span>, <span class="number">0</span>, imageW * <span class="number">0.5</span>, imageH)];</span><br><span class="line">        </span><br><span class="line">	<span class="comment">// 将图片取出</span></span><br><span class="line">	<span class="built_in">UIImage</span> *image = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">   </span><br><span class="line">	<span class="comment">// 关闭图形上下文</span></span><br><span class="line">	<span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">        </span><br><span class="line">	<span class="comment">// 在主线程上显示图片</span></span><br><span class="line">	<span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">		<span class="keyword">self</span>.imageView.image = image;</span><br><span class="line">	&#125;);</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"3%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="GCD定时器"><a href="#GCD定时器" class="headerlink" title="GCD定时器"></a>GCD定时器</h3><p>GCD定时器不受Mode影响因此比NSTimer要准确</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2.0</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">	<span class="comment">// 这句话的意思现在很好懂了</span></span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// GCD定时器</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 1.创建一个定时器源</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 参1:类型定时器</span></span><br><span class="line"><span class="comment">// 参2:句柄 </span></span><br><span class="line"><span class="comment">// 参3:mask传0 </span></span><br><span class="line"><span class="comment">// 参4:队列  (注意:dispatch_source_t本质是OC对象，表示源)</span></span><br><span class="line"><span class="keyword">self</span>.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, queue);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 严谨起见，时间间隔需要用单位int64_t，做乘法以后单位就变了</span></span><br><span class="line"><span class="comment">// 下面这句代码表示回调函数时间间隔是多少</span></span><br><span class="line">int64_t interval = (int64_t)(<span class="number">2.0</span> * <span class="built_in">NSEC_PER_SEC</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 如何设置开始时间 CGD给我们了一个设置时间的方法  </span></span><br><span class="line"><span class="comment">// 参1:dispatch_time_t when 传一个时间， delta是增量</span></span><br><span class="line"></span><br><span class="line">dispatch_time_t start = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">3.0</span> * <span class="built_in">NSEC_PER_SEC</span>)); <span class="comment">// 从现在起3秒后开始</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 2.设置定时器的各种属性</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">// 参1:timer </span></span><br><span class="line"><span class="comment">// 参2:开始时间 </span></span><br><span class="line"><span class="comment">// 参3:时间间隔 </span></span><br><span class="line"><span class="comment">// 参4:传0 不需要   DISPATCH_TIME_NOW 表示现在 GCD 时间用 NS 表示</span></span><br><span class="line">dispatch_source_set_timer(<span class="keyword">self</span>.timer, start, interval, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 3.设置回调(即每次间隔要做什么事情)</span></span><br><span class="line">dispatch_source_set_event_handler(<span class="keyword">self</span>.timer, ^&#123;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"----------------%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        </span><br><span class="line">	<span class="comment">// 如果希望做5次就停掉</span></span><br><span class="line">	count++;</span><br><span class="line">	<span class="keyword">if</span> (count == <span class="number">5</span>) &#123;</span><br><span class="line">		dispatch_cancel(<span class="keyword">self</span>.timer);</span><br><span class="line">		<span class="keyword">self</span>.timer = <span class="literal">nil</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 4.启动定时器  (恢复)</span></span><br><span class="line">dispatch_resume(<span class="keyword">self</span>.timer);</span><br></pre></td></tr></table></figure>

<p>讲完 GCD 就该讲讲 NSOperation，它是 GCD 的面向对象的封装，使用起来也更方便，</p>
<h2 id="NSOperation实现多线程"><a href="#NSOperation实现多线程" class="headerlink" title="NSOperation实现多线程"></a>NSOperation实现多线程</h2><p>NSOperation是个抽象类，并不具备封装操作的能力，必须使用它的子类</p>
<ul>
<li>NSInvocationOperation</li>
<li>NSBlockOperation</li>
<li>自定义子类继承NSOperation，实现内部相应的方法</li>
</ul>
<p>使用 NSOperation 实现多线程的步骤：</p>
<ol>
<li>创建任务 NSOperation 对象</li>
<li>创建 NSOperationQueue 队列</li>
<li>将任务 NSOperation 对象 add 到 NSOperationQueue 队列中去</li>
</ol>
<h3 id="NSInvocationOperation"><a href="#NSInvocationOperation" class="headerlink" title="NSInvocationOperation"></a>NSInvocationOperation</h3><p>代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSInvocationOperation</span> *op = [[<span class="built_in">NSInvocationOperation</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run) object:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">[op start];</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：默认情况下，调用了start方法后并不会开一条新的线程去执行，而是在当前线程同步执行操作，只有将 NSOperation 放到一个 NSOperationQueue 中，才会异步执行操作</p>
</blockquote>
<h3 id="NSBlockOperation"><a href="#NSBlockOperation" class="headerlink" title="NSBlockOperation"></a>NSBlockOperation</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSBlockOperation</span> *op = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">	<span class="comment">// 在主线程</span></span><br><span class="line">  	<span class="built_in">NSLog</span>(<span class="string">@"下载1------%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 添加额外的任务(在子线程执行)，封装数大于1才会异步执行</span></span><br><span class="line">[op addExecutionBlock:^&#123;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"下载2------%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">自定义Operation：需要实现- (<span class="keyword">void</span>)main方法，需要做的事情放在mian方法中</span><br></pre></td></tr></table></figure>

<h3 id="NSOperationQueue"><a href="#NSOperationQueue" class="headerlink" title="NSOperationQueue"></a>NSOperationQueue</h3><p>使用NSOperationQueue创建队列：主队列和全局队列</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个其他队列(包括串行队列和并发队列) 放到这个队列中的NSOperation对象会自动放到子线程中执行</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个主队列，放到这个队列中的NSOperation对象会自动放到子线程中执行</span></span><br><span class="line"><span class="built_in">NSOperationQueue</span> *mainQueue = [<span class="built_in">NSOperationQueue</span> mainQueue];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示并发数量：即同时执行任务的最大数。</span></span><br><span class="line">queue.maxConcurrentOperationCount = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h3 id="队列的取消、暂停、恢复："><a href="#队列的取消、暂停、恢复：" class="headerlink" title="队列的取消、暂停、恢复："></a>队列的取消、暂停、恢复：</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NSOpertion的 - cancel 方法也可以停止单个操作</span></span><br><span class="line">- (<span class="keyword">void</span>)cancelAllOperations; </span><br><span class="line"><span class="comment">// YES代表暂停队列，NO代表恢复队列</span></span><br><span class="line">- (<span class="keyword">void</span>)setSuspended:(<span class="built_in">BOOL</span>)b;</span><br></pre></td></tr></table></figure>

<h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line"><span class="built_in">NSBlockOperation</span> *block1 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"download1 -------------- %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSBlockOperation</span> *block2 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"download2 -------------- %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSBlockOperation</span> *block3 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"download3 -------------- %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 添加依赖: block1 和 block2执行完后 再执行 block3  block3依赖于block1和block2</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 给block3添加依赖 让block3在block1和block2之后执行</span></span><br><span class="line">[block3 addDependency:block1];</span><br><span class="line">[block3 addDependency:block2];</span><br><span class="line">    </span><br><span class="line">[queue addOperation:block1];</span><br><span class="line">[queue addOperation:block2];</span><br><span class="line">[queue addOperation:block3];</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：不能循环依赖，但可以跨队列依赖，不管NSOperation对象在哪个队列。只要是两个NSOperation对象就可以依赖</p>
</blockquote>
<h3 id="线程间通信-1"><a href="#线程间通信-1" class="headerlink" title="线程间通信"></a>线程间通信</h3><p>示例：下载图片</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 下载图片 operation实现线程间通信</span></span><br><span class="line">[[[<span class="built_in">NSOperationQueue</span> alloc] init] addOperation:[<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">	<span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithData:[<span class="built_in">NSData</span> dataWithContentsOfURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://7xjanq.com1.z0.glb.clouddn.com/6478.jpg"</span>]]];</span><br><span class="line">        </span><br><span class="line">	<span class="comment">// 返回主线程</span></span><br><span class="line">	[[<span class="built_in">NSOperationQueue</span> mainQueue] addOperation:[<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">		<span class="keyword">self</span>.imageView.image = image;</span><br><span class="line">	&#125;]];</span><br><span class="line">        </span><br><span class="line">&#125;]];</span><br></pre></td></tr></table></figure>


<p>示例：下载图片1和图片2 并合成图片</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 下载图片1</span></span><br><span class="line">__block <span class="built_in">UIImage</span> *image1 = <span class="literal">nil</span>;</span><br><span class="line"><span class="built_in">NSBlockOperation</span> *block1 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">	image1 = [<span class="built_in">UIImage</span> imageWithData:[<span class="built_in">NSData</span> dataWithContentsOfURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://7xjanq.com1.z0.glb.clouddn.com/6478.jpg"</span>]]];</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 下载图片2</span></span><br><span class="line">__block <span class="built_in">UIImage</span> *image2 = <span class="literal">nil</span>;</span><br><span class="line"><span class="built_in">NSBlockOperation</span> *block2 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">	image2 = [<span class="built_in">UIImage</span> imageWithData:[<span class="built_in">NSData</span> dataWithContentsOfURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://7xjanq.com1.z0.glb.clouddn.com/6478.jpg"</span>]]];</span><br><span class="line"></span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line"><span class="built_in">CGFloat</span> imageW = <span class="keyword">self</span>.imageView.bounds.size.width;</span><br><span class="line"><span class="built_in">CGFloat</span> imageH = <span class="keyword">self</span>.imageView.bounds.size.height;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 合成图片</span></span><br><span class="line"><span class="built_in">NSBlockOperation</span> *block3 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">	<span class="built_in">UIGraphicsBeginImageContext</span>(<span class="built_in">CGSizeMake</span>(imageW, imageH));</span><br><span class="line">	[image1 drawInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, imageW * <span class="number">0.5</span>, imageH)];</span><br><span class="line">	[image2 drawInRect:<span class="built_in">CGRectMake</span>(<span class="number">0.5</span> * imageW, <span class="number">0</span>, <span class="number">0.5</span> * imageW, imageH)];</span><br><span class="line">        </span><br><span class="line">	<span class="built_in">UIImage</span> *image3 = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">	<span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">	<span class="comment">// 切换回主线程显示图片</span></span><br><span class="line">	[[<span class="built_in">NSOperationQueue</span> mainQueue] addOperation:[<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">		<span class="keyword">self</span>.imageView.image = image3;</span><br><span class="line">	&#125;]];</span><br><span class="line">    </span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 设置依赖</span></span><br><span class="line">[block3 addDependency:block1];</span><br><span class="line">[block3 addDependency:block2];</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 添加任务到队列中</span></span><br><span class="line">[queue addOperation:block1];</span><br><span class="line">[queue addOperation:block2];</span><br><span class="line">[queue addOperation:block3];</span><br></pre></td></tr></table></figure>

<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>应用：SDWebImage 框架的底层主要功能实现就是基于多线程，使用多线程，我们可以实现小图片的多图片下载。这里的逻辑其实是比较复杂的</p>
<p>实现小图片的多图片下载思路：</p>
<p>代码实现见本文代码。</p>
<p>本文代码见：<a href="https://github.com/lizhaoLoveIT/Multithreading" target="_blank" rel="noopener">Multithreading</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Ammar</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://lizhaoloveit.cn/2015/03/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/">http://lizhaoloveit.cn/2015/03/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://lizhaoloveit.cn">Ammar's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/iOS/">iOS    </a></div><div class="post_share"><div class="social-share" data-image="https://lizhaoloveit.cn/blogimages/blog/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-buttom"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lozad post-qr-code__img" data-src="/img/wechat.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lozad post-qr-code__img" data-src="/img/alipay.jpg"><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull-left"><a href="/2015/04/06/%E6%8A%BD%E5%B1%89%E6%95%88%E6%9E%9C%E6%A1%86%E6%9E%B6/"><img class="prev_cover lozad" data-src="https://www.lizhaoloveit.cn/blogimages/blog/cover/1.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/2.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/3.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/4.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/5.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/6.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/7.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/8.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/9.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/10.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/11.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/12.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/13.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/14.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/15.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/16.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/17.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/18.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/19.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/20.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/21.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/22.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/23.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/24.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/25.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/26.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/27.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/28.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/29.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/31.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/32.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/33.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/34.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/35.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/36.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/37.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/38.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/39.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/40.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/41.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/42.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/43.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/44.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/45.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/46.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/47.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/48.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/49.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/50.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/51.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/52.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/53.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/54.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/55.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/56.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/57.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/58.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/59.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/60.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/62.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/63.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/64.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/65.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/66.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/67.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/68.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/69.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/70.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/71.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/72.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/73.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/74.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/75.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/76.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/77.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/78.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/79.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>抽屉效果框架</span></div></a></div><div class="next-post pull-right"><a href="/2015/03/05/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"><img class="next_cover lozad" data-src="https://www.lizhaoloveit.cn/blogimages/blog/cover/1.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/2.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/3.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/4.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/5.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/6.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/7.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/8.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/9.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/10.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/11.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/12.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/13.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/14.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/15.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/16.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/17.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/18.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/19.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/20.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/21.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/22.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/23.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/24.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/25.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/26.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/27.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/28.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/29.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/31.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/32.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/33.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/34.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/35.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/36.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/37.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/38.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/39.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/40.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/41.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/42.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/43.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/44.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/45.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/46.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/47.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/48.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/49.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/50.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/51.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/52.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/53.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/54.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/55.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/56.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/57.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/58.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/59.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/60.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/62.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/63.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/64.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/65.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/66.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/67.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/68.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/69.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/70.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/71.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/72.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/73.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/74.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/75.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/76.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/77.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/78.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/79.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>多线程基本概念</span></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i> <span>评论</span></div><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'http://lizhaoloveit.cn/2015/03/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/';
  this.page.identifier = '2015/03/06/多线程的实现方式/';
  this.page.title = '多线程的实现方式';
}
var d = document, s = d.createElement('script');
s.src = "https://" + 'lizhao' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script></div></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2014 - 2023 By Ammar</div><div class="icp"><a href="https://beian.miit.gov.cn/" target="_blank" rel="noopener"><span>浙ICP备19013619号-1</span></a></div><div class="bag"><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=33010502006128" target="_blank" rel="noopener"><img src="/img/beian.png"><span>浙公网安备 33010502006128号</span></a></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><section class="rightside" id="rightside"><i class="fa fa-book" id="readmode" title="阅读模式"> </i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换">繁</a><i class="far fa-moon nightshift" id="nightshift" title="夜间模式"></i></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script async src="/js/search/algolia.js"></script><script src="/js/nightshift.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()

</script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>