<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>Redis进阶 | Ammar's Blog</title><meta name="description" content="Redis进阶"><meta name="keywords" content="Redis"><meta name="author" content="Ammar"><meta name="copyright" content="Ammar"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.11.1/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="http://lizhaoloveit.cn/2020/07/09/Redis%E8%BF%9B%E9%98%B6/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="Redis进阶"><meta name="twitter:description" content="Redis进阶"><meta name="twitter:image" content="https://lizhaoloveit.cn/blogimages/blog/avatar.jpg"><meta property="og:type" content="article"><meta property="og:title" content="Redis进阶"><meta property="og:url" content="http://lizhaoloveit.cn/2020/07/09/Redis%E8%BF%9B%E9%98%B6/"><meta property="og:site_name" content="Ammar's Blog"><meta property="og:description" content="Redis进阶"><meta property="og:image" content="https://lizhaoloveit.cn/blogimages/blog/avatar.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="prev" title="MyBatis Generator" href="http://lizhaoloveit.cn/2020/07/28/MyBatis-Generator/"><link rel="next" title="MySQL进阶" href="http://lizhaoloveit.cn/2020/06/20/MySQL%E8%BF%9B%E9%98%B6/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script><!-- hexo-inject:begin --><!-- hexo-inject:end -->var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?162506e75ffd64287398566b2f5738c8";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"VRMKRAV9AT","apiKey":"bd7157400046d0f02396708a501a3480","indexName":"lizhaoloveit","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"cookieDomain":"https://lizhaoloveit.cn/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: '添加书签',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天'

  
}</script><meta name="generator" content="Hexo 4.2.1"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-数据类型的底层数据结构"><span class="toc-number">1.</span> <span class="toc-text">Redis 数据类型的底层数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#简单动态字符串-SDS"><span class="toc-number">1.1.</span> <span class="toc-text">简单动态字符串(SDS)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#链表"><span class="toc-number">1.2.</span> <span class="toc-text">链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字典"><span class="toc-number">1.3.</span> <span class="toc-text">字典</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#跳跃表"><span class="toc-number">1.4.</span> <span class="toc-text">跳跃表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#插入"><span class="toc-number">1.4.1.</span> <span class="toc-text">插入</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#整数集合"><span class="toc-number">1.5.</span> <span class="toc-text">整数集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#压缩列表"><span class="toc-number">1.6.</span> <span class="toc-text">压缩列表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IO-多路复用"><span class="toc-number">2.</span> <span class="toc-text">IO 多路复用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#同步IO-和-异步IO"><span class="toc-number">2.1.</span> <span class="toc-text">同步IO 和 异步IO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#阻塞-IO-和-非阻塞-IO"><span class="toc-number">2.2.</span> <span class="toc-text">阻塞 IO 和 非阻塞 IO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO多路复用-IO-Multiplexing"><span class="toc-number">2.3.</span> <span class="toc-text">IO多路复用 (IO Multiplexing)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#多路分离函数-select-操作系统"><span class="toc-number">2.3.1.</span> <span class="toc-text">多路分离函数 select (操作系统)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#异步-IO-Asynchronous-IO"><span class="toc-number">2.4.</span> <span class="toc-text">异步 IO (Asynchronous IO)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-IO-多路复用技术以及-epoll-实现原理"><span class="toc-number">3.</span> <span class="toc-text">Redis IO 多路复用技术以及 epoll 实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#实现机制"><span class="toc-number">3.1.</span> <span class="toc-text">实现机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#redis-epoll-底层实现"><span class="toc-number">3.1.1.</span> <span class="toc-text">redis epoll 底层实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-的缓存淘汰策略"><span class="toc-number">4.</span> <span class="toc-text">Redis 的缓存淘汰策略</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#淘汰策略-maxmemory-policy"><span class="toc-number">4.1.</span> <span class="toc-text">淘汰策略 maxmemory-policy</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LRU-实现原理"><span class="toc-number">4.1.1.</span> <span class="toc-text">LRU 实现原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-事务"><span class="toc-number">5.</span> <span class="toc-text">Redis 事务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#事务失败处理"><span class="toc-number">5.1.</span> <span class="toc-text">事务失败处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#语法错误"><span class="toc-number">5.1.1.</span> <span class="toc-text">语法错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#运行错误"><span class="toc-number">5.1.2.</span> <span class="toc-text">运行错误</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-持久化-RDB、AOF"><span class="toc-number">6.</span> <span class="toc-text">Redis 持久化(RDB、AOF)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-的应用场景"><span class="toc-number">7.</span> <span class="toc-text">Redis 的应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#如何选择存储策略-RDB-AOF"><span class="toc-number">7.1.</span> <span class="toc-text">如何选择存储策略 RDB AOF</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-的主从复制"><span class="toc-number">8.</span> <span class="toc-text">Redis 的主从复制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#配置"><span class="toc-number">8.1.</span> <span class="toc-text">配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#原理"><span class="toc-number">8.2.</span> <span class="toc-text">原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#全量同步"><span class="toc-number">8.2.1.</span> <span class="toc-text">全量同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#增量同步"><span class="toc-number">8.2.2.</span> <span class="toc-text">增量同步</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-哨兵机制"><span class="toc-number">9.</span> <span class="toc-text">Redis 哨兵机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#判断故障原理分析"><span class="toc-number">9.1.</span> <span class="toc-text">判断故障原理分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自动故障迁移"><span class="toc-number">9.2.</span> <span class="toc-text">自动故障迁移</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#案例演示"><span class="toc-number">9.3.</span> <span class="toc-text">案例演示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#启动哨兵服务"><span class="toc-number">9.4.</span> <span class="toc-text">启动哨兵服务</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-集群"><span class="toc-number">10.</span> <span class="toc-text">Redis 集群</span></a></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://lizhaoloveit.cn/blogimages/blog/top_img.jpg)"><div id="page-header"><span class="pull-left"> <a class="blog_title" id="site-name" href="/">Ammar's Blog</a></span><div class="open toggle-menu pull-right"><div class="menu-icon-first"></div><div class="menu-icon-second"></div><div class="menu-icon-third"></div></div><span class="pull-right menus"><div class="mobile_author_icon"><img class="lozad" data-src="https://lizhaoloveit.cn/blogimages/blog/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'"><div class="mobile_author-info__description">微信号：aicjaish</div></div><hr><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a><a class="site-page" href="/comment/"><i class="fa-fw fa fa-coffee"></i><span> 留言</span></a><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title"><div class="posttitle">Redis进阶</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-07-09<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-09-15</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Java/">Java</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Java/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></span><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">6.8k</span><span class="post-meta__separator">|</span><span>阅读时长: 23 分钟</span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><ul>
<!-- hexo-inject:begin --><!-- hexo-inject:end --><li>掌握 Redis 数据类型的底层数据结构</li>
<li>理解 IO 模型和 IO 多路复用及 Redis 的实现</li>
<li>理解 LRU</li>
<li>能够编写 Redis 事务处理，理解弱事务</li>
<li>理解 RedisRDB 和 AOF 持久化原理</li>
</ul>
<h1 id="Redis-数据类型的底层数据结构"><a href="#Redis-数据类型的底层数据结构" class="headerlink" title="Redis 数据类型的底层数据结构"></a>Redis 数据类型的底层数据结构</h1><hr>
<h2 id="简单动态字符串-SDS"><a href="#简单动态字符串-SDS" class="headerlink" title="简单动态字符串(SDS)"></a>简单动态字符串(SDS)</h2><p>simple dynamic string，默认字符串表示，结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">	<span class="comment">// 记录 buf 数组中已使用字节的数量</span></span><br><span class="line">	<span class="keyword">int</span> len;https:<span class="comment">//www.lizhaoloveit.cn/blogimages/java/database/redis</span></span><br><span class="line">	<span class="comment">// 记录 buf 数组中未使用字节的数量</span></span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line">	<span class="keyword">char</span> buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><img src="https://www.lizhaoloveit.cn/blogimages/java/database/redis/15943419705489-redis1.jpg"></p>
<p>好处：</p>
<ul>
<li>长度直接取出，常数复杂度获取字符串长度</li>
<li>杜绝缓冲区溢出 free 的作用</li>
</ul>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><hr>
<p>list 的底层实现之一就是双向链表，发布、订阅、慢查询、监视器等功能也用到了链表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">	<span class="comment">// 前置节点</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">	<span class="comment">// 节点的值</span></span><br><span class="line">	<span class="keyword">void</span> *value;</span><br><span class="line">&#125; listNode</span><br></pre></td></tr></table></figure>

<ul>
<li>链表节点使用 void *指针保存节点值，可以保存各种不同类型的值</li>
</ul>
<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><hr>
<p>字典又称为符号表，关联数组、或映射(map)，是一种用于保存键值对的抽象数据结构。字典中的每一个键 key 都是唯一的，通过 key 可以对值进行查找或修改。</p>
<p><img src="https://www.lizhaoloveit.cn/blogimages/java/database/redis/15943430400936-redis1.jpg"></p>
<p>哈希表作为底层实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">	<span class="comment">// 哈希表数组</span></span><br><span class="line">	dictEntry **table;</span><br><span class="line">	<span class="comment">// 哈希表大小</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">	<span class="comment">// 哈希表大小掩码，用于计算索引值</span></span><br><span class="line">	<span class="comment">// 总是等于 size - 1</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">	<span class="comment">// 改哈希表已有节点的数量</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125; dictht</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 哈希表是由数组 table 组成，table 中每一个元素指向</span></span><br><span class="line"><span class="comment"> * dict.h/dictEntry 结构，dictEntry 定义：</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">	<span class="comment">// 键</span></span><br><span class="line">	<span class="keyword">void</span> *key;</span><br><span class="line">	<span class="comment">// 值</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="keyword">void</span> *val;</span><br><span class="line">		uint64_tu64;</span><br><span class="line">		int64_ts64;</span><br><span class="line">	&#125; v;	</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 指向下一个哈希表节点，形成链表</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry</span><br></pre></td></tr></table></figure>

<h2 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h2><hr>
<p><img src="https://www.lizhaoloveit.cn/blogimages/java/database/redis/15943436136615-redis1.jpg"></p>
<p>普通单链表查询一个元素的时间复杂度为 O(n)，即使该单链表是有序的。</p>
<p>如果你构建一个数据结构，比链表查找还快，就用跳跃表。下面的链表是由上面的链表构建出的跳跃表</p>
<p><img src="https://www.lizhaoloveit.cn/blogimages/java/database/redis/15943446000576-redis1.jpg"></p>
<p>查找 46：55 -&gt; 21 -&gt; 55 -&gt; 37 -&gt; 55 -&gt; 46</p>
<p>大数从右找到头，小数从左往右找 和 21 比大小。</p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>初始状态</p>
<p><img src="https://www.lizhaoloveit.cn/blogimages/java/database/redis/15943455071690-redis1.jpg"></p>
<p>插入元素2</p>
<p><img src="https://www.lizhaoloveit.cn/blogimages/java/database/redis/15943455329972-redis1.jpg"></p>
<p>决定2 是否到L2层，采用百分之50的随机算法，如果中了，则2插入到 L2 层</p>
<p><img src="https://www.lizhaoloveit.cn/blogimages/java/database/redis/15943455824840-redis1.jpg"></p>
<p>继续执行随机算法，如果没中则停止插入。插入后表结构为上图，接下来插入33</p>
<p><img src="https://www.lizhaoloveit.cn/blogimages/java/database/redis/15943456290782-redis1.jpg"></p>
<p>插入后执行随机算法，33 没有能进入 L2 层，插入结束，接下来插入元素55.</p>
<p><img src="https://www.lizhaoloveit.cn/blogimages/java/database/redis/15943456932858-redis1.jpg"></p>
<p>55 中了2次 所以，L2 层 L3 层都需要插入 55 如下图</p>
<p><img src="https://www.lizhaoloveit.cn/blogimages/java/database/redis/15943457754398-redis1.jpg"></p>
<p>以此类推，如果规模较小，结果可能不是一个理想的跳跃表，如果元素n的规模很大，就会非常接近于理想的跳跃表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">	<span class="comment">// 层 </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span> </span><br><span class="line">		<span class="comment">// 前进指针 </span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span> </span><br><span class="line">		<span class="comment">// 跨度 </span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> span; </span><br><span class="line">	&#125; level[]; </span><br><span class="line">	<span class="comment">// 后退指针 </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span> </span><br><span class="line">	<span class="comment">// 分值 </span></span><br><span class="line">	<span class="keyword">double</span> score; </span><br><span class="line">	<span class="comment">// 成员对象 </span></span><br><span class="line">	robj *obj;</span><br><span class="line">&#125; zskiplistNode</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span> </span><br><span class="line">	<span class="comment">// 表头节点和表尾节点 </span></span><br><span class="line">	structz skiplistNode *header, *tail; </span><br><span class="line">	<span class="comment">// 表中节点的数量 </span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> length; </span><br><span class="line">	<span class="comment">// 表中层数最大的节点的层数 </span></span><br><span class="line">	<span class="keyword">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure>

<h2 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h2><hr>
<p>当一个集合 set 只包含整数元素，并且这个集合的元素不多，Redis 就会使用整数聚合 intset 作为该集合的底层实现。整数集合 intset 是 Redis 用于保存整数值的集合抽象数据类型，它可以保存类型为 int_t、int32_t 或者 int64_t 的整数值，并保证集合中不会出现重复元素。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">	<span class="comment">// 编码方式 </span></span><br><span class="line">	<span class="keyword">uint32_t</span> encoding; </span><br><span class="line">	<span class="comment">// 集合包含的元素数量 </span></span><br><span class="line">	<span class="keyword">uint32_t</span> length; </span><br><span class="line">	<span class="comment">// 保存元素的数组 </span></span><br><span class="line">	<span class="keyword">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>

<h2 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h2><hr>
<p>ziplist 是列表键和哈希键的底层实现之一，当一个列表值包含少量列表项时，并且每个列表项为小整数值或短字符串，那么 Redis 会使用压缩列表做该列表的底层实现。</p>
<p>压缩列表 ziplist 是 Redis 为了节省内存开发的，由一系列特殊编码的连续内存块组成的顺序型数据结构，一个压缩列表可以包含任意多个节点 (entry)，每个节点可以保存一个字节数组或者一个整数值。</p>
<h1 id="IO-多路复用"><a href="#IO-多路复用" class="headerlink" title="IO 多路复用"></a>IO 多路复用</h1><hr>
<p>Redis 单线程 性能高 使用 IO 多路复用处理并发。</p>
<h2 id="同步IO-和-异步IO"><a href="#同步IO-和-异步IO" class="headerlink" title="同步IO 和 异步IO"></a>同步IO 和 异步IO</h2><p><img src="https://www.lizhaoloveit.cn/blogimages/java/database/redis/15960729041221-redis1.jpg"></p>
<p>同步IO： 应用程序要的数据，需要等到操作系统给了才做其他事情。<br>异步IO： 应用程序要的数据，不需要等到内核控件给它就做别的事情，内核控件会异步通知应用程序，把数据直接给到应用程序。</p>
<h2 id="阻塞-IO-和-非阻塞-IO"><a href="#阻塞-IO-和-非阻塞-IO" class="headerlink" title="阻塞 IO 和 非阻塞 IO"></a>阻塞 IO 和 非阻塞 IO</h2><p>阻塞方式下读取或者写入函数将一直等待，而非阻塞方式下，函数会立即返回状态值。等数据准备就绪后，可以采用回调函数(call back) 的方式获得数据。</p>
<p><img src="https://www.lizhaoloveit.cn/blogimages/java/database/redis/15961048394372-redis1.jpg"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	-- socket 阻塞 </span><br><span class="line">	read(socket, buffer); </span><br><span class="line">	process(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同步非阻塞 IO</p>
<p><img src="https://www.lizhaoloveit.cn/blogimages/java/database/redis/15961049269212-redis1.jpg"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(read(socket, buffer) != SUCCESS);</span><br><span class="line">	process(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="IO多路复用-IO-Multiplexing"><a href="#IO多路复用-IO-Multiplexing" class="headerlink" title="IO多路复用 (IO Multiplexing)"></a>IO多路复用 (IO Multiplexing)</h2><h3 id="多路分离函数-select-操作系统"><a href="#多路分离函数-select-操作系统" class="headerlink" title="多路分离函数 select (操作系统)"></a>多路分离函数 select (操作系统)</h3><p>用户首先将需要进行IO操作的 socket 添加到 select 中，然后阻塞等待 select 系统调用返回。当数据到达时，socket 被激活，select 函数返回。用户线程正式发起 read 请求，读取数据并继续执行。</p>
<p><img src="https://www.lizhaoloveit.cn/blogimages/java/database/redis/15961052054130-redis1.jpg"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	select(socket); <span class="comment">// 操作系统的函数 监视 socket</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		sockets = select(); </span><br><span class="line">	-- 阻塞</span><br><span class="line">		<span class="keyword">for</span> (socket in sockets) &#123; </span><br><span class="line">			<span class="keyword">if</span> (can_read(socket)) &#123; </span><br><span class="line">				read(socket, buffer); </span><br><span class="line">				process(buffer);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Reactor 设计模式 (反应器)</p>
<p><img src="https://www.lizhaoloveit.cn/blogimages/java/database/redis/15961084546925-redis1.jpg"></p>
<p>IO 多路复用，也叫异步阻塞IO模型，通过 Reactor 的方式，可以将用户线程轮询IO操作工作统一交给 handle_events 事件循环进行处理。用户线程注册事件处理器之后可以继续执行做其他工作，而 Reactor 线程负责调用内核的 select 函数，检查 socket 状态。</p>
<p>当 socket 被激活时，通知相应的用户线程，执行 handle_event 函数进行数据读取、处理工作。由于 select 函数是阻塞的，多路 IO 复用模型也被称为异步阻塞 IO 模型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> UserEventHandler::handle_event() &#123;</span><br><span class="line">	<span class="keyword">if</span> (can_read(socket)) &#123;</span><br><span class="line">		read(socket, buffer);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="异步-IO-Asynchronous-IO"><a href="#异步-IO-Asynchronous-IO" class="headerlink" title="异步 IO (Asynchronous IO)"></a>异步 IO (Asynchronous IO)</h2><p><img src="https://www.lizhaoloveit.cn/blogimages/java/database/redis/15961138609251-redis1.jpg"></p>
<h1 id="Redis-IO-多路复用技术以及-epoll-实现原理"><a href="#Redis-IO-多路复用技术以及-epoll-实现原理" class="headerlink" title="Redis IO 多路复用技术以及 epoll 实现原理"></a>Redis IO 多路复用技术以及 epoll 实现原理</h1><hr>
<p>Redis 是跑在单线程中的，所有的操作都是按照顺序线性执行的，但是读写操作等待用户输入和输出都是阻塞的，所以I&#x2F;O操作一般不会直接返回，会导致某一文件的 I&#x2F;O阻塞，导致整个进程无法对其它用户提供服务。所以需要用 I&#x2F;O 多路复用解决这个问题。</p>
<h2 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h2><p>select &#x2F; poll &#x2F; epoll 都是 IO 多路复用的实现机制。</p>
<p>在  select&#x2F;poll 时代，服务器进程会每次把所有的连接告诉操作系统(从用户态复制句柄数据到内核态)，让操作系统内核去查询这些套接字(socket) 上是否有事件发生，轮询完后，再将句柄数据复制到用户态，让服务器应用程序轮询处理已发生的网络事件，由于资源消耗较大，因此，select&#x2F;poll 只能处理几千的并发连接。</p>
<p>epoll 是 poll 的一种优化，返回后不需要对所有的连接(fd) 进行遍历，在内核中维持了 连接(fd)的列表。</p>
<ol>
<li>调用 epoll_create() 建立一个 epoll 对象。在epoll 文件系统中为这个句柄对象分配资源</li>
<li>调用 epoll_ctl 向 epoll 对象中添加所有的连接的套接字</li>
<li>调用 epoll_wait 收集发生的事件的连接</li>
</ol>
<h3 id="redis-epoll-底层实现"><a href="#redis-epoll-底层实现" class="headerlink" title="redis epoll 底层实现"></a>redis epoll 底层实现</h3><p>当进程调用 epoll_create 方法时，Linux 内核会创建一个 eventpoll 结构体，这个结构体中有两个成员与 epoll 的使用方式密切相关。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span>&#123;</span></span><br><span class="line">	<span class="comment">// 红黑树的根节点，这颗树种存储着所有添加到 epoll 中的需要监控的事件</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">rbr</span>;</span></span><br><span class="line">	<span class="comment">// 双链表中则存放着将要通过 epoll_wait 返回给用户的满足条件的事件</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdlist</span>;</span></span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>每一个 epoll 对象都有一个独立的 eventpoll 结构体，用于存放通过 epoll_ctl 方法向 epoll 对象中添加进来的事件。</p>
<p>这些事件都会挂载在红黑树中，如此，重复添加的事件就可以通过红黑树而高效的识别出来，红黑树插入的时间效率是 logn，n 为树的高度。</p>
<p>所有添加到 epoll 中的事件都会与设备网卡建立回调关系，当相应的事件发生时会调用回调方法 ep_poll_callback。</p>
<p>epoll_wait-&gt;ep_poll-&gt;ep_poll_callback 在 epoll 中，每一个事件都会建立一个 epitem 结构体，然后将 epitem 放到 rdlist中，说白了是将 socket 放到 event 中再将持有 event 的 epitem 放到 rdlist 中，此过程 epoll_wait 阻塞，插入后，所有添加到 epoll 的事件都会与网卡驱动程序建立回调关系，当事件发生时会调用这个回调方法，这个回调方法在内核中叫 ep_poll_callback。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epitem</span>&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rbn</span>;</span> <span class="comment">// 红黑树节点</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdllink</span>;</span> <span class="comment">// 双向链表节点</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epoll_filefd</span> <span class="title">ffd</span>;</span> <span class="comment">// 事件句柄信息</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span> <span class="comment">// 指向其所属的 eventpoll 对象</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span> <span class="comment">// 期待发生的事件类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>epoll 初始化时，会开辟出 epoll 自己的内核高速 cache 服务于 epoll，安置每一个需要监控的 socket，这些 socket 会以红黑树的形式保存在内核的 cache 里，支持快速查找、插入、删除。这个内核高速 cache 区，就是建立连续的物理内存页，然后在之上建立 slab 层。在初始化时已经分配好了 size 内存对象，每次使用时都是使用空闲的已经分配好的对象。</p>
</blockquote>
<blockquote>
<p>在内核中，一切皆文件。epoll 向内核注册了一个文件系统，用于存储上述被监控的 socket。当调用 epoll_create 时，就会在 epoll 文件系统里创建一个 file 节点，它只服务于 epoll。</p>
</blockquote>
<blockquote>
<p>epoll_create 除了建立节点和红黑树存储 socket 外，还会建立一个 list 链表，存储准备就绪的事件，当 epoll_wait 调用时，仅仅观察这个 list 链表里有没有数据即可。有数据就返回，没有数据就 sleep。等到 timeout 时，如果链表没有数据也返回。所以 epoll_wait 非常高效。</p>
</blockquote>
<p>相较于 select&#x2F;poll，epoll 的优势就是不用重复传递 socket 句柄给内核。因为内核在 epoll_ctl 方法中就已经获取了要监控的 socket 句柄列表。</p>
<h1 id="Redis-的缓存淘汰策略"><a href="#Redis-的缓存淘汰策略" class="headerlink" title="Redis 的缓存淘汰策略"></a>Redis 的缓存淘汰策略</h1><hr>
<p>redis 中，允许用户设置最大使用的内存大小 maxmemory，默认为0，即没有指定最大缓存。如果有新数据添加，超过最大内存，则 redis 会崩溃。redis 内存数据集大小上升到一定大小的时候，会执行数据淘汰策略。</p>
<h2 id="淘汰策略-maxmemory-policy"><a href="#淘汰策略-maxmemory-policy" class="headerlink" title="淘汰策略 maxmemory-policy"></a>淘汰策略 maxmemory-policy</h2><p>六种数据淘汰策略：</p>
<ol>
<li>voltile-lru: 从已设置过期时间的数据集(server.db[i].expires) 中挑选最近最少使用的数据淘汰</li>
<li>volatile-ttl: 从已设置过期时间的数据集(server.db[i].expires) 中挑选将要过期的数据淘汰</li>
<li>volatile-random: 从已设置过期时间的数据集(server.db[i].expires) 中任意选择数据淘汰</li>
<li>allkeys-lru: 从数据集(server.db[i].dict) 中挑选最近最少使用的数据淘汰(默认，一般使用此策略)</li>
<li>allkeys-random: 从数据集(server.db[i].dict) 中任意选择数据淘汰</li>
<li>no-enviction(驱逐) : 禁止驱逐数据</li>
</ol>
<h3 id="LRU-实现原理"><a href="#LRU-实现原理" class="headerlink" title="LRU 实现原理"></a>LRU 实现原理</h3><p>LRU 最近最少使用，算法根据数据的历史访问记录来进行淘汰数据，其核心思想是，如果数据最近被访问过，将来被访问的记录也更高。</p>
<p><img src="https://www.lizhaoloveit.cn/blogimages/java/database/redis/15965216673928-redis1.jpg"></p>
<p>Java 中可以使用 LinkHashMap 去实现 LRU</p>
<p>算法：利用哈希链表实现</p>
<p>假设，我们使用哈希链表缓存用户信息，目前缓存了5个用户，这5个用户按时间顺序依次从链表右端插入。</p>
<p>此时如果业务访问了用户2，哈希链表中存在用户2的数据，则把它从前去节点和后继节点之间移除，重新插入到链表最右端。最左端还是1.</p>
<p><img src="https://www.lizhaoloveit.cn/blogimages/java/database/redis/15965223984706-redis1.jpg"></p>
<p>接下来，业务修改了用户4的信息，则将用户4移到了最右端。最左端仍然是访问最少的用户1</p>
<p><img src="https://www.lizhaoloveit.cn/blogimages/java/database/redis/15965224576498-redis1.jpg"></p>
<p>后来业务访问了新的用户6，6在缓存中没有，需要插入到哈希链表，假设此时缓存容量已达上限。必须先删除访问最少的数据，那么位于哈希链表最左端用户1就会被删除。然后把6插入到最右端。</p>
<h1 id="Redis-事务"><a href="#Redis-事务" class="headerlink" title="Redis 事务"></a>Redis 事务</h1><hr>
<ul>
<li>Redis 的事务通过 MULTI、EXEC、DISCARD 和 WATCH 这四个命令完成的</li>
<li>Redis 的单个命令都是原子性的，所以这里需要确保事务性的对象是命令集合</li>
<li>Redis 将命令集合序列化并确保处于同一事务的命令集合连续且不被打断的执行</li>
<li>Redis 不支持回滚操作</li>
</ul>
<p>MULTI: 标记事务块开始<br>EXEC: 执行所有先前放入队列的命令，事务结束<br>DISCARD: 清除队列<br>WATCH: 监控某个 key 的 value，当值变化则队列被清除，可以实现 Redis 的乐观锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; set s1 11</span><br><span class="line">OK</span><br><span class="line">&gt; set s2 22</span><br><span class="line">OK</span><br><span class="line">&gt; multi</span><br><span class="line">OK</span><br><span class="line">&gt; set s2 33</span><br><span class="line">QUEUED  &#x2F;&#x2F; 说明在队列中了 此时在另一个会话上访问 get s2 ，仍然是22</span><br><span class="line">&gt; set s3 44</span><br><span class="line">QUEUED  &#x2F;&#x2F; 两条命令都在队列里 此时在另一个会话上访问 get s3 nil</span><br><span class="line">&gt; exec</span><br><span class="line">OK</span><br><span class="line">OK      &#x2F;&#x2F; 两条命令同时执行，此时一个事务就完成了</span><br></pre></td></tr></table></figure>

<p>WATCH 演示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; get s1</span><br><span class="line">11</span><br><span class="line">&gt; watch s1</span><br><span class="line">OK</span><br><span class="line">&gt; multi</span><br><span class="line">OK</span><br><span class="line">&gt; set a1 11</span><br><span class="line">QUEUED</span><br><span class="line">&gt; set a2 22</span><br><span class="line">QUEUED		&#x2F;&#x2F; 此时，如果再另一个会话中修改了 s1 的值，则再执行 exec 时会出现 nil</span><br><span class="line">&gt; exec		&#x2F;&#x2F; watch 可以实现乐观锁</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<h2 id="事务失败处理"><a href="#事务失败处理" class="headerlink" title="事务失败处理"></a>事务失败处理</h2><h3 id="语法错误"><a href="#语法错误" class="headerlink" title="语法错误"></a>语法错误</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; multi</span><br><span class="line">OK</span><br><span class="line">&gt; sets a1 11</span><br><span class="line">(error) ERR unknown command &#96;sets&#96;, with args beginning with &#96;q1&#96;, &#96;11&#96;</span><br><span class="line">&gt; set a2 22</span><br><span class="line">QUEUED	</span><br><span class="line">&gt; exec		</span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors.</span><br></pre></td></tr></table></figure>
<p>语法错误命令队列都不执行</p>
<h3 id="运行错误"><a href="#运行错误" class="headerlink" title="运行错误"></a>运行错误</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; multi</span><br><span class="line">OK</span><br><span class="line">&gt; set a1 11</span><br><span class="line">QUEUED</span><br><span class="line">&gt; lpush a1 1 2 3</span><br><span class="line">QUEUED</span><br><span class="line">&gt; exec		</span><br><span class="line">OK</span><br><span class="line">(error) WRONGTYPE Operation against a key holding the wrong kind of value</span><br></pre></td></tr></table></figure>

<p>a1 是个字符串了，不能被当成数组使用，第一个执行成功了。语法错误和运行错误不同。</p>
<h1 id="Redis-持久化-RDB、AOF"><a href="#Redis-持久化-RDB、AOF" class="headerlink" title="Redis 持久化(RDB、AOF)"></a>Redis 持久化(RDB、AOF)</h1><hr>
<p>Redis 是一个内存数据库，为了保证数据的持久性，提供了2个持久化方案</p>
<p>RDB(默认): 通过 snapshotting 完成，快照。当符合一定条件时，Redis 会自动将内存中的数据进行快照并持久化到硬盘中。</p>
<blockquote>
<p>触发快照的时机: 符合自定义配置的快照规则，执行save或者bgsave 命令，执行 flushall 命令，执行主从复制操作(第一次)</p>
</blockquote>
<p><img src="https://www.lizhaoloveit.cn/blogimages/java/database/redis/15966071804727-redis1.jpg"></p>
<p>RDB 规则: <code>save &lt;seconds&gt; &lt;changes&gt;</code> 多少秒内，数据变了多少。</p>
<ul>
<li>save “” 表示不使用 RDB</li>
<li>save 900 1: 表示 15 分钟(900s) 内至少1个键被更改则进行快照。</li>
<li>save 300 10: 表示 5 分钟内至少有10个键被更改则进行快照</li>
<li>save 60 10000: 表示 1 分钟内至少有10000个键被更改则进行快照</li>
</ul>
<blockquote>
<p>使用 RDB 方式实现持久化，一旦 Redis 异常退出，就会丢失最后一次快照以后更改的所有数据。如果数据比较重要，可以使用 AOF 方式进行持久化。<br>RDB 可以最大化 Redis 性能，父进程在保存 RDB 文件时唯一要做的就是 fork 出一个子进程，然后这个子进程就会处理接下来所有的保存工作。但如果数据集较大，fork 会比较耗时，造成服务器在一段时间内停止处理客户端请求。</p>
</blockquote>
<p>AOF: append only file，基于 RESP 实现。</p>
<p>默认不开启 AOF</p>
<p>开启 AOF 持久化后，每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入硬盘中的 AOF 文件，这一过程显然会降低 Redis 的性能，但大部分情况下这个影响是可以接受的，使用较快的硬盘可以提高 AOF 性能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 通过修改 redis.conf 配置文件中的 appendonly 参数开启</span><br><span class="line">appendonly yes</span><br><span class="line"># AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的</span><br><span class="line">dir .&#x2F;</span><br><span class="line"># 默认的文件名是 appendonly.aof，可以通过 appendfilename 参数修改</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br></pre></td></tr></table></figure>


<p>RESP Redis 的序列化协议，</p>
<p><img src="https://www.lizhaoloveit.cn/blogimages/java/database/redis/15976312133958-redis1.jpg"></p>
<p>AOF 文件中存储的是 redis 的指令。</p>
<p><img src="https://www.lizhaoloveit.cn/blogimages/java/database/redis/15976322944435-redis1.jpg"></p>
<p>重写 AOF 优化指令：</p>
<p>Redis 在创建新的 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里，保证安全性。一旦新的 AOF 文件创建文笔，Redis 就会从旧 AOF 文件切换到新的 AOF 文件，并开始对新的 AOF 文件进行追加操作。</p>
<p>优化触发条件： 表示当前 aof 文件大小超过上一次 aof 文件大小的百分之多少时进行重写。如果之前没有重写过，启动的时候已 aof 文件大小为准</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto-aof-rewrite-percentage 100</span><br></pre></td></tr></table></figure>

<p>限制允许重写最小 aof 文件大小，也就是文件大小小于64mb 时，不需要进行优化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto-aof-rewrite-min-size 64mb</span><br></pre></td></tr></table></figure>

<h1 id="Redis-的应用场景"><a href="#Redis-的应用场景" class="headerlink" title="Redis 的应用场景"></a>Redis 的应用场景</h1><hr>
<p>内存数据库  不需要存在 DB 中的数据，登录信息、浏览记录、购物车</p>
<p>缓存服务器  缓存 DB 信息 减少 DB 压力，商品数据信息</p>
<p>session 存储 多个应用服务器</p>
<p>任务队列  list 秒杀系统 请求限流</p>
<p>分布式锁 set nx</p>
<p>应用排行 zset</p>
<p>数据过期 冷热数据</p>
<h2 id="如何选择存储策略-RDB-AOF"><a href="#如何选择存储策略-RDB-AOF" class="headerlink" title="如何选择存储策略 RDB AOF"></a>如何选择存储策略 RDB AOF</h2><p>内存数据库  rdb + aof  数据不丢失</p>
<p>缓存服务器  rdb</p>
<p>不建议只使用 aof ，因为性能差</p>
<h1 id="Redis-的主从复制"><a href="#Redis-的主从复制" class="headerlink" title="Redis 的主从复制"></a>Redis 的主从复制</h1><hr>
<p><img src="https://www.lizhaoloveit.cn/blogimages/java/database/redis/15988681847912-redis1.jpg"></p>
<p><img src="https://www.lizhaoloveit.cn/blogimages/java/database/redis/15988682414542-redis1.jpg"></p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>主 Redis 数据库不需要额外配置。从 Redis 修改 redis.conf 文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line"># 表示当前 从服务器对应的 主服务器的 IP 是 192.168.10.135，端口是 6379</span><br><span class="line">slaveof 192.168.10.135 6379</span><br></pre></td></tr></table></figure>

<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Redis 的主从同步，分为全量同步和增量同步，只有第一次连接上主机是全量同步，断线重连有可能触发全量同步也有可能是增量同步，master 判断 runid 是否一致。除此之外均是增量同步</p>
<p><img src="https://www.lizhaoloveit.cn/blogimages/java/database/redis/15988684252911-redis1.jpg"></p>
<h3 id="全量同步"><a href="#全量同步" class="headerlink" title="全量同步"></a>全量同步</h3><ul>
<li>同步快照阶段：Master 创建并发送快照给 slave，slave 载入并解析快照。Master 同时将此阶段产生的新的写命令存储到缓冲区。</li>
<li>同步写缓冲阶段：Master 向 slave 同步存储在缓冲区的写操作命令。</li>
<li>同步增量阶段：Master 向 Slave 同步写操作指令。</li>
</ul>
<h3 id="增量同步"><a href="#增量同步" class="headerlink" title="增量同步"></a>增量同步</h3><ul>
<li>Redis 增量同步指 Slave 完成初始化后开始正常工作时，Master 发生的写操作同步到 Slave 的过程。</li>
<li>通常情况下，Master 每执行一个写命令就会向 Slave 发送相同的写命令，然后 Slave 接受并执行。</li>
</ul>
<h1 id="Redis-哨兵机制"><a href="#Redis-哨兵机制" class="headerlink" title="Redis 哨兵机制"></a>Redis 哨兵机制</h1><hr>
<p>Redis 的哨兵模式是从 2.8 版本后才有。</p>
<p>Sentinel 进程用于监控 Redis 集群中 Master 主服务器工作的状态</p>
<p>在 Master 主服务器发生故障的时候，可以实现 Master 和 Slave 服务器切换，保证系统的高可用。HA</p>
<ul>
<li>监控(Monitoring)，哨兵会不断的检查 Master 和 Slave 是否运转正常</li>
<li>提醒(Notification) 当被监控的某个 Redis 节点出现问题，哨兵可以通过 API 向管理员或者其他应用程序发送通知。</li>
<li>自动故障迁移(Automatic failover) 当一个 Master 不能正常工作时，哨兵会开始一次自动故障迁移操作。</li>
</ul>
<h2 id="判断故障原理分析"><a href="#判断故障原理分析" class="headerlink" title="判断故障原理分析"></a>判断故障原理分析</h2><p><img src="https://www.lizhaoloveit.cn/blogimages/java/database/redis/15988688952071-redis1.jpg"></p>
<ol>
<li>每个 Sentinel 进程以每秒一次的频率向整个集群中的 Master 主服务器，Slave 从服务器以及其他 Sentinel 进程发送一个 PING 命令。</li>
<li>如果一个实例距离最后一次有效回复 PING 命令的时间超过 <code>down-after-milliseconds</code> 选项指定的值，则这个实例会被 Sentinel 进程标记为主观下线 SDown</li>
<li>如果一个 Master 主服务器被标记为主观下线 SDown，则正在件事这个 Master 主服务器的所有 Sentinel 进程要以每秒一次的频率确认 Master 主服务器的确进入了主观下线状态</li>
<li>在足够多的 Sentinel 进程(大于等于配置文件指定的值) 在指定的时间范围内确认主服务器进入了主观下线状态，则 Master 主服务器会被标记为客观下线状态，ODown。</li>
<li>当 Master 主服务器被 Sentinel 进程标记为 客观下线状态 ODown时，Sentinel 进程向下线的 Master 主服务器所有的 Slave 从服务器发送 <code>INFO</code> 指令的频率从10秒一次改为1秒一次。一般情况下，每个 Sentinel 进程会以 10 秒一次的频率向集群中所有 Master主服务器、Slave 从服务器发送 <code>INFO</code> 命令。</li>
<li>如果没有足够数量的 Sentinel 进程同意 Master 主服务器下线，Master 主服务器的客观下线状态就会被移除。如果 Master 主服务器重新向 Sentinel 进程发送的 PING 命令返回有效回复，Master 主服务器的主观下线状态就会被移除。</li>
</ol>
<h2 id="自动故障迁移"><a href="#自动故障迁移" class="headerlink" title="自动故障迁移"></a>自动故障迁移</h2><p>它会将失效的 Master 其中一个 Slave 升级为新 Master 并让失效 Master 的其他 Slave 改为复制新的 Master，客户端视图连接失效的 Master 时，集群会向客户端返回新 Master 的地址，使得集群可以使用现在的 Master 替换失效 Master。</p>
<p>服务器切换后，Master 的 redis.conf Slave 的 redis.conf 和 Sentinel.conf 的配置文件的内容都会发生相应的改变。</p>
<p>Master 主服务器的 redis.conf 配置文件中会多一行 slaveof 的配置，Sentinel.conf 的监控目标会随之调换。</p>
<h2 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h2><p>sentinel.conf</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"># 哨兵 Sentinel 监控的 redis 主节点的 ip port</span><br><span class="line"># master-name 可以自己命名主节点 A-z 0-9 .-_ 组成</span><br><span class="line"># quorum Sentinel 哨兵 认为 Master 主节点主观掉线的数量大于 quorum 时，Master 主节点状态为 客观掉线 ODnow </span><br><span class="line"># sentinel monitor &lt;master-name&gt; &lt;master ip&gt; &lt;master port&gt; &lt;quorum&gt;</span><br><span class="line">sentinel monitor mymaster 192.168.10.133 6379 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 哨兵 Sentinel 实例运行端口 默认 26379</span><br><span class="line">port 26379</span><br><span class="line"></span><br><span class="line"># 哨兵 Sentinel 的工作目录</span><br><span class="line">dir &#x2F;tmp</span><br><span class="line"></span><br><span class="line"># 哨兵 Sentinel 监控的 redis 主节点的 ip port</span><br><span class="line"># master-name 可以自己命名主节点 A-z 0-9 .-_ 组成</span><br><span class="line"># quorum Sentinel 哨兵 认为 Master 主节点主观掉线的数量大于 quorum 时，Master 主节点状态为 客观掉线 ODnow </span><br><span class="line"># sentinel monitor &lt;master-name&gt; &lt;master ip&gt; &lt;master port&gt; &lt;quorum&gt;</span><br><span class="line">sentinel monitor mymaster 192.168.10.133 6379 1</span><br><span class="line"></span><br><span class="line"># 当 redis 实例开启了 requirepass foobared 授权密码，这样所有连接 Redis 实例的客户端都要提供密码</span><br><span class="line"># 设置哨兵 Sentinel 连接主从的密码 注意必须为主从设置一样的验证密码</span><br><span class="line"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span><br><span class="line">sentinel auth-pass mymaster Mysssss</span><br><span class="line"></span><br><span class="line"># 指定多少毫秒后 主节点没有应答哨兵 Sentinel ，此时哨兵主观上认为主节点下线 默认30秒</span><br><span class="line"># sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line"></span><br><span class="line"># 这个配置项指定了在发生 failover 主备切换时最多可以有多少个 slave 同时对新的 master 进行同步，</span><br><span class="line"># 数字越小，完成 failover 所需时间就越长</span><br><span class="line"># 但是，如果数字越大，意味着越多的 slave 因为 replication 不可用</span><br><span class="line"># 可以通过将值设为1 保证每次只有一个 slave 处于不能处理命令请求的状态</span><br><span class="line"># sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"></span><br><span class="line"># 故障转移的超时时间 failover-timeout 可以用在以下方面</span><br><span class="line"># 1. 同一个 Sentinel 对同一个 Master 两次 failover 之间的间隔时间</span><br><span class="line"># 2. 当一个 Slave 从一个错误的 Master 那里同步数据开始计算时间，直到 Slave 被纠正为向正确的 Master 那里同步数据时</span><br><span class="line"># 3. 当想要取消一个正在进行的 failover 所需时间</span><br><span class="line"># 4. 当进行 failover 时，配置所有 Slaves 指向新的 Master 所需的最大时间，不过，即使过了这个超时，Slaves 依然会被正确配置为指向 Master，但是就是不按 parallel-syncs 配置的规则了</span><br><span class="line"></span><br><span class="line"># 默认3分钟</span><br><span class="line"># sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line"></span><br><span class="line"># 配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通 知相关人员。</span><br><span class="line"># 对于脚本的运行结果有以下规则：</span><br><span class="line"># 若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10</span><br><span class="line"># 若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。</span><br><span class="line"># 如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。</span><br><span class="line"># 一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。</span><br><span class="line"></span><br><span class="line"># 通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等）， </span><br><span class="line"># 将会去调用这个脚本，这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。</span><br><span class="line"># 调用该脚本时，将传给脚本两个参数，一个是事件的类型，一个是事件的描述。</span><br><span class="line"># 如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执 行的，</span><br><span class="line"># 否则sentinel无法正常启动成功。</span><br><span class="line"># 通知脚本</span><br><span class="line"># sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;</span><br><span class="line">sentinel notification-script mymaster &#x2F;var&#x2F;redis&#x2F;notify.sh</span><br><span class="line"></span><br><span class="line"># 客户端重新配置主节点参数脚本</span><br><span class="line"># 当一个 Master 由于 failover 发生改变时，这个脚本将会被调用，通知相关的客户端关于 Master 地址已经发生改变的信息。</span><br><span class="line"></span><br><span class="line"># 以下参数会在调用脚本时传给脚本：</span><br><span class="line"></span><br><span class="line"># &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;</span><br><span class="line"># 目前 &lt;state&gt; 总是 failover</span><br><span class="line"># &lt;role&gt;是 &quot;leader&quot; 或者 &quot;observer&quot; 中一个</span><br><span class="line"># 参数 from-ip，from-port，to-ip，to-port 是用来和旧的 Master 和新的 Master 通信的</span><br><span class="line"># 这个脚本应该是通用而能被多次调用的，不是针对性的</span><br><span class="line"># sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</span><br><span class="line">sentinel client-reconfig-script mymaster &#x2F;var&#x2F;redis&#x2F;reconfig.sh</span><br></pre></td></tr></table></figure>

<h2 id="启动哨兵服务"><a href="#启动哨兵服务" class="headerlink" title="启动哨兵服务"></a>启动哨兵服务</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-sentinel sentinel.conf</span><br></pre></td></tr></table></figure>

<h1 id="Redis-集群"><a href="#Redis-集群" class="headerlink" title="Redis 集群"></a>Redis 集群</h1><hr>
<!-- 5-4 28课 25分20秒  54分14秒 操作视频 -->
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Ammar</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://lizhaoloveit.cn/2020/07/09/Redis%E8%BF%9B%E9%98%B6/">http://lizhaoloveit.cn/2020/07/09/Redis%E8%BF%9B%E9%98%B6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://lizhaoloveit.cn">Ammar's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Redis/">Redis    </a></div><div class="post_share"><div class="social-share" data-image="https://lizhaoloveit.cn/blogimages/blog/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-buttom"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lozad post-qr-code__img" data-src="/img/wechat.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lozad post-qr-code__img" data-src="/img/alipay.jpg"><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull-left"><a href="/2020/07/28/MyBatis-Generator/"><img class="prev_cover lozad" data-src="https://www.lizhaoloveit.cn/blogimages/blog/cover/1.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/2.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/3.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/4.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/5.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/6.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/7.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/8.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/9.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/10.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/11.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/12.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/13.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/14.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/15.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/16.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/17.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/18.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/19.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/20.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/21.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/22.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/23.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/24.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/25.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/26.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/27.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/28.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/29.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/31.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/32.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/33.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/34.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/35.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/36.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/37.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/38.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/39.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/40.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/41.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/42.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/43.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/44.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/45.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/46.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/47.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/48.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/49.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/50.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/51.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/52.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/53.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/54.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/55.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/56.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/57.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/58.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/59.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/60.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/62.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/63.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/64.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/65.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/66.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/67.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/68.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/69.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/70.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/71.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/72.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/73.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/74.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/75.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/76.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/77.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/78.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/79.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>MyBatis Generator</span></div></a></div><div class="next-post pull-right"><a href="/2020/06/20/MySQL%E8%BF%9B%E9%98%B6/"><img class="next_cover lozad" data-src="https://www.lizhaoloveit.cn/blogimages/blog/cover/1.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/2.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/3.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/4.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/5.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/6.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/7.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/8.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/9.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/10.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/11.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/12.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/13.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/14.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/15.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/16.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/17.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/18.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/19.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/20.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/21.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/22.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/23.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/24.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/25.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/26.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/27.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/28.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/29.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/31.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/32.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/33.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/34.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/35.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/36.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/37.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/38.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/39.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/40.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/41.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/42.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/43.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/44.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/45.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/46.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/47.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/48.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/49.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/50.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/51.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/52.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/53.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/54.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/55.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/56.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/57.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/58.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/59.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/60.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/62.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/63.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/64.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/65.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/66.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/67.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/68.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/69.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/70.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/71.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/72.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/73.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/74.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/75.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/76.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/77.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/78.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/79.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>MySQL进阶</span></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i> <span>评论</span></div><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'http://lizhaoloveit.cn/2020/07/09/Redis%E8%BF%9B%E9%98%B6/';
  this.page.identifier = '2020/07/09/Redis进阶/';
  this.page.title = 'Redis进阶';
}
var d = document, s = d.createElement('script');
s.src = "https://" + 'lizhao' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script></div></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2014 - 2024 By Ammar</div><div class="icp"><a href="https://beian.miit.gov.cn/" target="_blank" rel="noopener"><span>浙ICP备19013619号-1</span></a></div><div class="bag"><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=33010502006128" target="_blank" rel="noopener"><img src="/img/beian.png"><span>浙公网安备 33010502006128号</span></a></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><section class="rightside" id="rightside"><i class="fa fa-book" id="readmode" title="阅读模式"> </i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换">繁</a><i class="far fa-moon nightshift" id="nightshift" title="夜间模式"></i></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script async src="/js/search/algolia.js"></script><script src="/js/nightshift.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()

</script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><!-- hexo-inject:begin --><!-- hexo-inject:end --></body></html>