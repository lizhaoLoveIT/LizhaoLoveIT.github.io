<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>树 | Ammar's Blog</title><meta name="description" content="树"><meta name="keywords" content="数据结构与算法"><meta name="author" content="Ammar"><meta name="copyright" content="Ammar"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.11.1/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="http://lizhaoloveit.cn/2019/06/23/%E6%A0%91/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="树"><meta name="twitter:description" content="树"><meta name="twitter:image" content="https://lizhaoloveit.cn/blogimages/blog/avatar.jpg"><meta property="og:type" content="article"><meta property="og:title" content="树"><meta property="og:url" content="http://lizhaoloveit.cn/2019/06/23/%E6%A0%91/"><meta property="og:site_name" content="Ammar's Blog"><meta property="og:description" content="树"><meta property="og:image" content="https://lizhaoloveit.cn/blogimages/blog/avatar.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="prev" title="反射" href="http://lizhaoloveit.cn/2019/06/26/%E5%8F%8D%E5%B0%84/"><link rel="next" title="HashMap底层设计实现" href="http://lizhaoloveit.cn/2019/06/19/HashMap%E5%BA%95%E5%B1%82%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script><!-- hexo-inject:begin --><!-- hexo-inject:end -->var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?162506e75ffd64287398566b2f5738c8";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"VRMKRAV9AT","apiKey":"bd7157400046d0f02396708a501a3480","indexName":"lizhaoloveit","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"cookieDomain":"https://lizhaoloveit.cn/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: '添加书签',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天'

  
}</script><meta name="generator" content="Hexo 4.2.1"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#树-Tree-的基本概念"><span class="toc-number">1.</span> <span class="toc-text">树(Tree)的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#二叉树-Binary-Tree"><span class="toc-number">1.1.</span> <span class="toc-text">二叉树(Binary Tree)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#真二叉树"><span class="toc-number">1.2.</span> <span class="toc-text">真二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#完全二叉树-complete-Binary-Tree"><span class="toc-number">1.3.</span> <span class="toc-text">完全二叉树(complete Binary Tree)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一些国外的说法"><span class="toc-number">1.4.</span> <span class="toc-text">一些国外的说法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二叉搜索树-Binary-Search-Tree"><span class="toc-number">2.</span> <span class="toc-text">二叉搜索树 (Binary Search Tree)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#二叉搜索树的接口设计"><span class="toc-number">2.1.</span> <span class="toc-text">二叉搜索树的接口设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二叉搜索树的遍历"><span class="toc-number">2.2.</span> <span class="toc-text">二叉搜索树的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#前序遍历-Preorder-Traversal"><span class="toc-number">2.2.1.</span> <span class="toc-text">前序遍历 (Preorder Traversal)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#中序遍历-Inorder-Traversal"><span class="toc-number">2.2.2.</span> <span class="toc-text">中序遍历 (Inorder Traversal)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#后序遍历-Postorder-Traversal"><span class="toc-number">2.2.3.</span> <span class="toc-text">后序遍历 (Postorder Traversal)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#层序遍历-level-Order-Traversal-需要会默写"><span class="toc-number">2.2.4.</span> <span class="toc-text">层序遍历 (level Order Traversal) 需要会默写</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#前驱节点和后继节点"><span class="toc-number">2.3.</span> <span class="toc-text">前驱节点和后继节点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#练习104：计算二叉树的高度"><span class="toc-number">2.3.1.</span> <span class="toc-text">练习104：计算二叉树的高度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#练习：判断一棵树是否为完全二叉树"><span class="toc-number">2.3.2.</span> <span class="toc-text">练习：判断一棵树是否为完全二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#练习226：翻转二叉树"><span class="toc-number">2.3.3.</span> <span class="toc-text">练习226：翻转二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#练习114：二叉树展开为链表"><span class="toc-number">2.3.4.</span> <span class="toc-text">练习114：二叉树展开为链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#练习589：N叉树的前序遍历"><span class="toc-number">2.3.5.</span> <span class="toc-text">练习589：N叉树的前序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#练习590：N叉树的后序遍历"><span class="toc-number">2.3.6.</span> <span class="toc-text">练习590：N叉树的后序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#练习106：从中序与后序遍历序列构造二叉树"><span class="toc-number">2.3.7.</span> <span class="toc-text">练习106：从中序与后序遍历序列构造二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#练习105：从前序与中序遍历序列构造二叉树"><span class="toc-number">2.3.8.</span> <span class="toc-text">练习105：从前序与中序遍历序列构造二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#练习889：根据前序和后序遍历构造二叉树"><span class="toc-number">2.3.9.</span> <span class="toc-text">练习889：根据前序和后序遍历构造二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#练习：寻找搜索二叉树的前驱节点-predecessor-和后继节点-successor"><span class="toc-number">2.3.10.</span> <span class="toc-text">练习：寻找搜索二叉树的前驱节点(predecessor)和后继节点(successor)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二叉搜索树的删除"><span class="toc-number">2.4.</span> <span class="toc-text">二叉搜索树的删除</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二叉搜索树的复杂度分析"><span class="toc-number">2.5.</span> <span class="toc-text">二叉搜索树的复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#平衡二叉搜索树"><span class="toc-number">3.</span> <span class="toc-text">平衡二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#AVL树"><span class="toc-number">3.1.</span> <span class="toc-text">AVL树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#添加节点"><span class="toc-number">3.1.1.</span> <span class="toc-text">添加节点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#LL-右旋转（单旋）"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">LL-右旋转（单旋）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RR-左旋转"><span class="toc-number">3.1.1.2.</span> <span class="toc-text">RR-左旋转</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LR-RR左旋转-gt-LL右旋转-双旋"><span class="toc-number">3.1.1.3.</span> <span class="toc-text">LR-RR左旋转-&gt;LL右旋转(双旋)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RL-LL右旋转-gt-RR左旋转-双旋"><span class="toc-number">3.1.1.4.</span> <span class="toc-text">RL-LL右旋转-&gt;RR左旋转(双旋)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#删除节点"><span class="toc-number">3.1.2.</span> <span class="toc-text">删除节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AVL树的平均时间复杂度"><span class="toc-number">3.1.3.</span> <span class="toc-text">AVL树的平均时间复杂度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#B树"><span class="toc-number">3.2.</span> <span class="toc-text">B树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#m阶B树的性质-m-ge-2"><span class="toc-number">3.2.1.</span> <span class="toc-text">m阶B树的性质 m$\ge$2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B树搜索"><span class="toc-number">3.2.2.</span> <span class="toc-text">B树搜索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B树添加-例子为4阶B树"><span class="toc-number">3.2.3.</span> <span class="toc-text">B树添加-例子为4阶B树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B树删除-例子为5阶B树"><span class="toc-number">3.2.4.</span> <span class="toc-text">B树删除-例子为5阶B树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#红黑树"><span class="toc-number">3.3.</span> <span class="toc-text">红黑树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#红黑树的特性"><span class="toc-number">3.3.1.</span> <span class="toc-text">红黑树的特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#红黑树的等价变换"><span class="toc-number">3.3.2.</span> <span class="toc-text">红黑树的等价变换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#添加"><span class="toc-number">3.3.3.</span> <span class="toc-text">添加</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#删除"><span class="toc-number">3.3.4.</span> <span class="toc-text">删除</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#思考：代码中的afterRemove方法，可以只传一个参数"><span class="toc-number">3.3.4.1.</span> <span class="toc-text">思考：代码中的afterRemove方法，可以只传一个参数</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://lizhaoloveit.cn/blogimages/blog/top_img.jpg)"><div id="page-header"><span class="pull-left"> <a class="blog_title" id="site-name" href="/">Ammar's Blog</a></span><div class="open toggle-menu pull-right"><div class="menu-icon-first"></div><div class="menu-icon-second"></div><div class="menu-icon-third"></div></div><span class="pull-right menus"><div class="mobile_author_icon"><img class="lozad" data-src="https://lizhaoloveit.cn/blogimages/blog/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'"><div class="mobile_author-info__description">微信号：aicjaish</div></div><hr><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a><a class="site-page" href="/comment/"><i class="fa-fw fa fa-coffee"></i><span> 留言</span></a><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title"><div class="posttitle">树</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-06-23<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2023-04-19</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></span><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">7.1k</span><span class="post-meta__separator">|</span><span>阅读时长: 26 分钟</span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><!-- https://www.lizhaoloveit.cn/blogArticles/数据结构与算法/media -->

<!-- hexo-inject:begin --><!-- hexo-inject:end --><blockquote>
<p>声明：博文所有内容不是原创，是学习李明杰老师的腾讯课堂课程：《恋上数据结构与算法》后的总结。</p>
</blockquote>
<h1 id="树-Tree-的基本概念"><a href="#树-Tree-的基本概念" class="headerlink" title="树(Tree)的基本概念"></a>树(Tree)的基本概念</h1><p>兄弟节点：同一个父节点下的子节点互相叫做兄弟节点。</p>
<p><strong>空数：一棵树没有任何节点</strong></p>
<p>子树：父节点下的子节点为根节点所构成的树</p>
<p>左子树：父节点下的左子节点所构成的树，同理右子树</p>
<p><strong>节点的度(degree)：子树的个数</strong></p>
<p><strong>树的度(degree)：所有节点度中的最大值</strong></p>
<p><strong>叶子节点(leaf)：度为0的节点，度不为0的叫非叶子节点</strong> </p>
<p><strong>层数(lever)：根节点在第一层，根节点的子节点在第二层，以此类推</strong></p>
<p><strong>节点的深度(depth)：从根节点到当前节点的唯一路径上的节点总数，树的深度，所有节点深度中的最大值</strong></p>
<p><strong>节点的高度(height)：从当前节点到最远叶子节点的路径上的节点总数，树的高度，所有节点高度中的最大值</strong></p>
<p>树的深度&#x3D;树的高度</p>
<h2 id="二叉树-Binary-Tree"><a href="#二叉树-Binary-Tree" class="headerlink" title="二叉树(Binary Tree)"></a>二叉树(Binary Tree)</h2><p><img src="https://www.lizhaoloveit.cn/blogArticles/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/media/15612904331236-tree.jpg"></p>
<p>特点：</p>
<ul>
<li>每个节点的度最大为2.度只可能是 0，1，2</li>
<li>左子树和右子树是有顺序的(有序树)</li>
<li>即使某节点只有一颗子树，也要区分左右子树</li>
</ul>
<p>性质：</p>
<p><img src="https://www.lizhaoloveit.cn/blogArticles/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/media/15612909388996-tree.jpg"></p>
<ul>
<li>非空二叉树的第 i 层，最多有 2^(i - 1) 个节点 (i &gt;&#x3D; 1)</li>
<li>在高度为 h 的二叉树上最多有 2^h - 1 个节点 (h &gt;&#x3D; 1)</li>
<li>对于任何一棵非空二叉树，如果叶子节点个数为 n0， 度为2的节点个数为 n2， 则有 n0 &#x3D; n2 + 1<ul>
<li>2x &#x3D; x + x&#x2F;2 + x&#x2F;4 +…+2+1 + 1</li>
</ul>
</li>
</ul>
<blockquote>
<p>证明：<br>假设度为1的节点个数为 n1，那么二叉树的节点总数 n &#x3D; n0 + n1 + n2<br>二叉树的边数 T &#x3D; n1 + 2 * n2 &#x3D; n - 1 &#x3D; n0 + n1 + n2 - 1</p>
</blockquote>
<h2 id="真二叉树"><a href="#真二叉树" class="headerlink" title="真二叉树"></a>真二叉树</h2><p><strong>真二叉树：所有节点的度要么为0，要么为2，满二叉树：所有的叶子节点都在最后一层的真二叉树叫满二叉树</strong></p>
<p><img src="https://www.lizhaoloveit.cn/blogArticles/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/media/15612991483725-tree.jpg"></p>
<p>同样高度的二叉树中，满二叉树的叶子节点数量最多、总节点数最多，满二叉树一定是真二叉树，真二叉树不一定是满二叉树。</p>
<p>假设满二叉树的高度为 h (h &gt;&#x3D; 1)，那么  </p>
<ol>
<li>第 i 层的节点数量：2^(i - 1)</li>
<li>叶子节点数量：2^(h - 1)</li>
<li>总节点数量 n<ul>
<li>n &#x3D; 2^h - 1</li>
<li>h &#x3D; log2(n + 1)</li>
</ul>
</li>
</ol>
<h2 id="完全二叉树-complete-Binary-Tree"><a href="#完全二叉树-complete-Binary-Tree" class="headerlink" title="完全二叉树(complete Binary Tree)"></a>完全二叉树(complete Binary Tree)</h2><p>叶子节点只会出现最后 2 层，且最后 1 层的叶子节点都靠左对齐，完全二叉树从根节点至倒数第二层是一颗满二叉树</p>
<p><img src="https://www.lizhaoloveit.cn/blogArticles/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/media/15612990713006-tree.jpg"></p>
<ul>
<li>度为1的节点只有左子树</li>
<li>度为1的节点要么是1个，要么是0个</li>
<li>同样节点数量的二叉树，完全二叉树的高度最小</li>
<li>假设完全二叉树的高度为 h (h &gt;&#x3D; 1)，那么<ul>
<li>至少有 2^(h - 1)次方个节点</li>
<li>最多有 2^h - 1 个节点</li>
<li>2^(h-1) &lt;&#x3D; n &lt; 2^h </li>
<li>h - 1 &lt;&#x3D; log2n &lt; h，h &#x3D; floor(log2n) + 1</li>
</ul>
</li>
</ul>
<blockquote>
<p>floor(n) 向下取整，   ceiling(n) 向上取整</p>
</blockquote>
<p><strong>有一颗有 n 个节点的完全二叉树 (n &gt; 0)， 从上到下、从左到右对节点 1 开始进行编号，对任意第 i 个节点</strong></p>
<ul>
<li>如果 i &#x3D; 1， 它是根节点</li>
<li>如果 i &gt; 1，它的父节点编号为 floor(i &#x2F; 2)</li>
<li>如果 2i &lt;&#x3D; n，它的左子节点编号为 2i</li>
<li>如果 2i &gt; n，它无左子节点</li>
<li>如果 2i + 1 &lt;&#x3D; n，它的右子节点编号为 2i + 1</li>
<li>如果 2i + 1 &gt; n，它无右子节点</li>
</ul>
<p><strong>有一颗有 n 个节点的完全二叉树 (n &gt; 0)， 从上到下、从左到右对节点 0 开始进行编号，对任意第 i 个节点</strong></p>
<ul>
<li>如果 i &#x3D; 0， 它是根节点</li>
<li>如果 i &gt; 0，它的父节点编号为 floor((i - 1) &#x2F; 2)</li>
<li>如果 2i + 1 &lt;&#x3D; n - 1，它的左子节点编号为 2i + 1</li>
<li>如果 2i + 1 &gt; n - 1，它无左子节点</li>
<li>如果 2i + 2 &lt;&#x3D; n - 1，它的右子节点编号为 2i + 2</li>
<li>如果 2i + 1 &gt; n，它无右子节点</li>
</ul>
<blockquote>
<p>面试题：如果一颗完全二叉树有768个节点，求叶子节点的个数<br>假设叶子节点个数为 n0，度为1的节点个数为 n1，度为2的节点个数为 n2，总节点个数为 n &#x3D; n0 + n1 + n2，且 n0 &#x3D; n2 + 1， n &#x3D; 2n0 + n1 - 1，非叶子节点个数也是 n &#x2F; 2<br>完全二叉树的 n1 要么为0，要么为1，因此，当 n1 为1时，n &#x3D; 2n0，n 必然是偶数，n1 为 0 时， n &#x3D; 2n0 - 1，n必然为奇数，n0 &#x3D; (n + 1) &#x2F; 2。 非叶子节点个数是 (n - 1) &#x2F; 2<br>通用公式：n0 &#x3D; floor ((n + 1) &#x2F; 2) 最终代码: n0 &#x3D; (n + 1) &gt;&gt; 1 或者 (n &gt;&gt; 1) + 1</p>
</blockquote>
<h2 id="一些国外的说法"><a href="#一些国外的说法" class="headerlink" title="一些国外的说法"></a>一些国外的说法</h2><ul>
<li>Full Binary Tree 完满二叉树，就是 真二叉树，所有非叶子节点的度都为2</li>
<li>Perfect Binary Tree 完美二叉树，所有非叶子节点的度都为2，且所有叶子节点都在最后一层，即国内说的”满二叉树”</li>
<li>Complete Binary Tree 完全二叉树 ，跟国内定义一样</li>
</ul>
<p><img src="https://www.lizhaoloveit.cn/blogArticles/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/media/15613022503553-tree.jpg"></p>
<h1 id="二叉搜索树-Binary-Search-Tree"><a href="#二叉搜索树-Binary-Search-Tree" class="headerlink" title="二叉搜索树 (Binary Search Tree)"></a>二叉搜索树 (Binary Search Tree)</h1><blockquote>
<p>思考<br>在 n 个动态的整数中搜索某个整数<br>假设使用动态数组存放元素，从第 0 个位置开始遍历搜索，平均时间复杂度为 O(n)<br>如果使用的是有序的动态数组，使用二分搜索，最坏时间复杂度：O(logn)，但是添加删除的平均复杂度为 O(n)</p>
</blockquote>
<p>针对上述需求，使用二叉搜索树，添加、删除、搜索的最坏时间复杂度均可优化至：O(logn)</p>
<p>二叉搜索树是二叉树的一种，应用非常广泛的一种二叉树，英文简称 BST</p>
<p>又被称为：二叉查找树、二叉排序树</p>
<p><img src="https://www.lizhaoloveit.cn/blogArticles/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/media/15613033190239-tree.jpg"></p>
<p>特点：</p>
<ul>
<li>任意一个节点的值都大于它左子树所有节点的值</li>
<li>任意一个节点的值都小于其右子树所有节点的值</li>
<li>它的左右子树也是一棵二叉搜索树</li>
<li>二叉搜索树存储的元素必须具备可比较性</li>
<li>不允许为 null</li>
</ul>
<h2 id="二叉搜索树的接口设计"><a href="#二叉搜索树的接口设计" class="headerlink" title="二叉搜索树的接口设计"></a>二叉搜索树的接口设计</h2><p>搜索二叉树需要实现的接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>; <span class="comment">// 元素数量</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="comment">// 是否为空</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> <span class="comment">// 清空所有元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span> <span class="comment">// 增加元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(E element)</span> <span class="comment">// 删除元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E element)</span> <span class="comment">// 是否包含某元素</span></span></span><br></pre></td></tr></table></figure>

<p>对于我们现在使用的二叉树来说，它的元素没有索引的概念</p>
<blockquote>
<p>为什么？<br>添加顺序与元素大小无关。而且添加顺序与元素的层数也无关。</p>
</blockquote>
<h2 id="二叉搜索树的遍历"><a href="#二叉搜索树的遍历" class="headerlink" title="二叉搜索树的遍历"></a>二叉搜索树的遍历</h2><h3 id="前序遍历-Preorder-Traversal"><a href="#前序遍历-Preorder-Traversal" class="headerlink" title="前序遍历 (Preorder Traversal)"></a>前序遍历 (Preorder Traversal)</h3><p>根节点、前序遍历左子树、前序遍历右子树</p>
<ol>
<li>递归</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preorderTraversal</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    System.out.println(node.element);</span><br><span class="line">    preorderTraversal(node.left);</span><br><span class="line">    preorderTraversal(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>迭代</li>
</ol>
<h3 id="中序遍历-Inorder-Traversal"><a href="#中序遍历-Inorder-Traversal" class="headerlink" title="中序遍历 (Inorder Traversal)"></a>中序遍历 (Inorder Traversal)</h3><p>中序遍历左子树、根节点、右子树</p>
<p>二叉搜索树，中序遍历结果是升序或者降序的</p>
<h3 id="后序遍历-Postorder-Traversal"><a href="#后序遍历-Postorder-Traversal" class="headerlink" title="后序遍历 (Postorder Traversal)"></a>后序遍历 (Postorder Traversal)</h3><p>县访问左子树、再访问右子树、再访问根节点</p>
<h3 id="层序遍历-level-Order-Traversal-需要会默写"><a href="#层序遍历-level-Order-Traversal-需要会默写" class="headerlink" title="层序遍历 (level Order Traversal) 需要会默写"></a>层序遍历 (level Order Traversal) 需要会默写</h3><p>实现思路：使用队列</p>
<ol>
<li>将根节点入队</li>
<li>循环执行以下操作，直到队列为空<ul>
<li>将队头节点 A 出队，进行访问。</li>
<li>将 A 的左节点入队</li>
<li>将 A 的右子节点入队</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrdertranversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    Queue&lt;Node&lt;E&gt;&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        Node&lt;E&gt; node = queue.poll();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 打印 node 节点的元素，这里写遍历要做的事</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.offer(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思考，如果允许外界遍历二叉树的元素，如何设计接口<br>采用给遍历方法，传递一个接口，接口的方法中放入业务代码的方式。内部当获取到遍历的元素时，调用对象的接口方法来操作元素。</p>
</blockquote>
<h2 id="前驱节点和后继节点"><a href="#前驱节点和后继节点" class="headerlink" title="前驱节点和后继节点"></a>前驱节点和后继节点</h2><p><img src="https://www.lizhaoloveit.cn/blogArticles/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/media/image-20230330083943626.png" alt="image-20230330083943626"></p>
<p>前驱节点 predecessor，指中序遍历时的前一个节点，根节点8的前驱节点是7。</p>
<p>求一个二叉树的前驱节点思路：</p>
<ul>
<li>如果节点的左子树不为null<ul>
<li>predecessor &#x3D; node.left.right.right…</li>
<li>终止条件为 right &#x3D; null</li>
</ul>
</li>
<li>如果节点的左子树为null，且节点的父节点不为空<ul>
<li>predecessor &#x3D; node.parent.parent…</li>
<li>终止条件为 node.parent.right &#x3D; node (node在parent的右子树中)</li>
</ul>
</li>
<li>如果节点的左子树为null，节点的 parent 也为 null<ul>
<li>没有前驱节点</li>
</ul>
</li>
</ul>
<p><img src="https://www.lizhaoloveit.cn/blogArticles/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/media/image-20230330094222009.png" alt="image-20230330094222009"></p>
<p>后继节点 successor，中序遍历的后一个节点</p>
<ul>
<li>如果 node.right !&#x3D; null<ul>
<li>successor &#x3D; node.right.left.left…</li>
<li>终止条件：left &#x3D; null</li>
</ul>
</li>
<li>如果 node.right &#x3D;&#x3D; null &amp;&amp; node.parent !&#x3D; null<ul>
<li>successor &#x3D; node.parent.parent…</li>
<li>终止条件 node.parent.left &#x3D; node(node在parent的左子树中)</li>
</ul>
</li>
<li>node.right &#x3D;&#x3D; null &amp;&amp; node.parent &#x3D;&#x3D; null 没有后继节点</li>
</ul>
<h3 id="练习104：计算二叉树的高度"><a href="#练习104：计算二叉树的高度" class="headerlink" title="练习104：计算二叉树的高度"></a>练习104：计算二叉树的高度</h3><p><strong><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">https://leetcode.cn/problems/maximum-depth-of-binary-tree/</a></strong></p>
<p>递归：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + Math.max(height(node.left), height(node.right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代：层序遍历 要知道一层有多少个</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> height = <span class="number">0</span>; <span class="comment">// 存储树的高度</span></span><br><span class="line">    <span class="keyword">int</span> levelSize = <span class="number">1</span>; <span class="comment">// 存储着每一层的元素数量，第一层的元素数量为1</span></span><br><span class="line">    Queue&lt;Node&lt;E&gt;&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        Node&lt;E&gt; node = queue.poll();</span><br><span class="line">        <span class="comment">// 每当取出一个元素，意味着每一层的元素数量--</span></span><br><span class="line">        levelSize--;</span><br><span class="line">        <span class="comment">// 打印 node 节点的元素，这里写遍历要做的事</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.offer(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (levelSize == <span class="number">0</span>) &#123; </span><br><span class="line">            <span class="comment">// 意味着即将要访问下一层，所以队列中存储着下一层的所有元素，层数++ </span></span><br><span class="line">            levelSize = queue.size();</span><br><span class="line">            height++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="练习：判断一棵树是否为完全二叉树"><a href="#练习：判断一棵树是否为完全二叉树" class="headerlink" title="练习：判断一棵树是否为完全二叉树"></a>练习：判断一棵树是否为完全二叉树</h3><p>完全二叉树的叶子节点从上到下，从左到右排列。</p>
<blockquote>
<p>思路：层序遍历，判断最高层数之前的每一层是否是满二叉树，<br>如果树为空，返回 false<br>如果树不为空，开始层序遍历二叉树(用队列)<br>如果node.left !&#x3D; null，&amp;&amp; node.right !&#x3D; null，将node.left 、 node.right 按顺序入队<br>如果node.left &#x3D;&#x3D; null &amp;&amp; node.right !&#x3D; null，返回false<br>如果node.left !&#x3D; null &amp;&amp; node.right &#x3D;&#x3D; null 或者 node.left &#x3D;&#x3D; null &amp;&amp; node.right &#x3D;&#x3D; null 说明接下来所有节点都是叶子节点。如果有不是叶子节点的节点存在，则返回 false</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否为完全二叉树</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Queue&lt;Node&lt;E&gt;&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">boolean</span> leaf = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        Node&lt;E&gt; node = queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (leaf &amp;&amp; !node.isLeaf()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//      if (node.hasTwoChildren()) &#123;</span></span><br><span class="line"><span class="comment">//          queue.offer(node.left);</span></span><br><span class="line"><span class="comment">//          queue.offer(node.right);</span></span><br><span class="line"><span class="comment">//      &#125; else if (node.left == null &amp;&amp; node.right != null) &#123;</span></span><br><span class="line"><span class="comment">//          return false;</span></span><br><span class="line"><span class="comment">//      &#125; else if (node.left != null &amp;&amp; node.right == null) &#123;</span></span><br><span class="line"><span class="comment">//          queue.offer(node.left);</span></span><br><span class="line"><span class="comment">//          leaf = true;</span></span><br><span class="line"><span class="comment">//      &#125; else &#123;</span></span><br><span class="line"><span class="comment">//          leaf = true;</span></span><br><span class="line"><span class="comment">//      &#125;</span></span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.offer(node.left);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.offer(node.right);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            leaf = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="练习226：翻转二叉树"><a href="#练习226：翻转二叉树" class="headerlink" title="练习226：翻转二叉树"></a>练习226：翻转二叉树</h3><p><strong><a href="https://leetcode.cn/problems/invert-binary-tree/" target="_blank" rel="noopener">https://leetcode.cn/problems/invert-binary-tree/</a></strong></p>
<p><img src="https://www.lizhaoloveit.cn/blogArticles/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/media/image-20230328225229618.png" alt="image-20230328225229618"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 思路，将所有叶子节点的左右子树交换</span></span><br><span class="line"><span class="comment"> * 前序遍历节点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将节点的左右交换</span></span><br><span class="line">    TreeNode tmp = root.left;</span><br><span class="line">    root.left = root.right;</span><br><span class="line">    root.right = tmp;</span><br><span class="line"></span><br><span class="line">    invertTree(root.left);</span><br><span class="line">    invertTree(root.right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="练习114：二叉树展开为链表"><a href="#练习114：二叉树展开为链表" class="headerlink" title="练习114：二叉树展开为链表"></a>练习114：二叉树展开为链表</h3><p><a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="noopener">https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/</a></p>
<p>给你二叉树的根结点 root ，请你将它展开为一个单链表：</p>
<p>展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。<br>展开后的单链表应该与二叉树 先序遍历 顺序相同。</p>
<p><img src="https://www.lizhaoloveit.cn/blogArticles/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/media/flaten.jpg" alt="flaten"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span> || (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 将左子树变为链表</span></span><br><span class="line">    flatten(root.left);</span><br><span class="line">    <span class="comment">// 将右子树变为链表</span></span><br><span class="line">    flatten(root.right);</span><br><span class="line">    <span class="comment">// 将右子树的链表拼接到左子树链表的末尾的右边</span></span><br><span class="line">    TreeNode left = root.left;</span><br><span class="line">    <span class="keyword">while</span> (left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeNode leftRight = left.right;</span><br><span class="line">        <span class="keyword">if</span> (leftRight == <span class="keyword">null</span>) &#123;</span><br><span class="line">            left.right = root.right;</span><br><span class="line">            root.right = root.left;</span><br><span class="line">            root.left = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        left = leftRight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="练习589：N叉树的前序遍历"><a href="#练习589：N叉树的前序遍历" class="headerlink" title="练习589：N叉树的前序遍历"></a>练习589：N叉树的前序遍历</h3><p><strong><a href="https://leetcode.cn/problems/n-ary-tree-preorder-traversal/" target="_blank" rel="noopener">https://leetcode.cn/problems/n-ary-tree-preorder-traversal/</a></strong></p>
<h3 id="练习590：N叉树的后序遍历"><a href="#练习590：N叉树的后序遍历" class="headerlink" title="练习590：N叉树的后序遍历"></a>练习590：N叉树的后序遍历</h3><p><strong><a href="https://leetcode.cn/problems/n-ary-tree-postorder-traversal/" target="_blank" rel="noopener">https://leetcode.cn/problems/n-ary-tree-postorder-traversal/</a></strong></p>
<h3 id="练习106：从中序与后序遍历序列构造二叉树"><a href="#练习106：从中序与后序遍历序列构造二叉树" class="headerlink" title="练习106：从中序与后序遍历序列构造二叉树"></a>练习106：从中序与后序遍历序列构造二叉树</h3><p><strong><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" target="_blank" rel="noopener">https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/</a></strong></p>
<p>给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。</p>
<p><img src="https://www.lizhaoloveit.cn/blogArticles/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/media/tree.jpg" alt="tree"></p>
<p>解题思路：</p>
<p><img src="https://www.lizhaoloveit.cn/blogArticles/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/media/ac050d257073f47285353d7ad412fb832326237ea85948a8b69d338171d67543-%E6%A0%91%E7%9A%84%E8%BF%98%E5%8E%9F.png" alt="ac050d257073f47285353d7ad412fb832326237ea85948a8b69d338171d67543-树的还原"></p>
<h3 id="练习105：从前序与中序遍历序列构造二叉树"><a href="#练习105：从前序与中序遍历序列构造二叉树" class="headerlink" title="练习105：从前序与中序遍历序列构造二叉树"></a>练习105：从前序与中序遍历序列构造二叉树</h3><p><strong><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/</a></strong></p>
<h3 id="练习889：根据前序和后序遍历构造二叉树"><a href="#练习889：根据前序和后序遍历构造二叉树" class="headerlink" title="练习889：根据前序和后序遍历构造二叉树"></a>练习889：根据前序和后序遍历构造二叉树</h3><p><strong><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/" target="_blank" rel="noopener">https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/</a></strong></p>
<h3 id="练习：寻找搜索二叉树的前驱节点-predecessor-和后继节点-successor"><a href="#练习：寻找搜索二叉树的前驱节点-predecessor-和后继节点-successor" class="headerlink" title="练习：寻找搜索二叉树的前驱节点(predecessor)和后继节点(successor)"></a>练习：寻找搜索二叉树的前驱节点(predecessor)和后继节点(successor)</h3><p>概念：如果一颗二叉树存在左子树，其前驱节点是左子树最右边的节点。</p>
<p>若该节点存在右子树，则其后继节点为右子树最左边的节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取任意节点的前驱节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">predecessor</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    TreeNode p = node.left;</span><br><span class="line">    <span class="comment">// 如果左子树不为空，前驱节点就是左子树中最右边的节点</span></span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (p.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            p = p.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果左子树为空，前驱节点就是父节点或者 node = node.parent.right 的时候的 parent</span></span><br><span class="line">    <span class="keyword">while</span> (node.parent != <span class="keyword">null</span> &amp;&amp; node == node.parent.left) &#123;</span><br><span class="line">        node = node.parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 要么 node.parent == null，要么 node == node.parent.right</span></span><br><span class="line">    <span class="keyword">return</span> node.parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">successor</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    TreeNode p = node.right;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (p.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (node.parent != <span class="keyword">null</span> &amp;&amp; node == node.parent.right) &#123;</span><br><span class="line">        node = node.parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node.parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉搜索树的删除"><a href="#二叉搜索树的删除" class="headerlink" title="二叉搜索树的删除"></a>二叉搜索树的删除</h2><p>分两种情况，分别为度为一或者零的节点、度为二的节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    size--;</span><br><span class="line">    <span class="comment">// 度为2的节点</span></span><br><span class="line">    <span class="keyword">if</span> (node.hasTwoChildren()) &#123;</span><br><span class="line">        <span class="comment">// 找到后继节点</span></span><br><span class="line">        TreeNode&lt;E&gt; s = successor(node);</span><br><span class="line">        <span class="comment">// 用后继节点的值覆盖度为2的节点的值</span></span><br><span class="line">        node.val = s.val;</span><br><span class="line">        <span class="comment">// 删除后继节点</span></span><br><span class="line">        node = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除node节点(node的度必然是1或者0)</span></span><br><span class="line">    TreeNode&lt;E&gt; replacement = node.left != <span class="keyword">null</span> ? node.left : node.right;</span><br><span class="line">    <span class="keyword">if</span> (replacement != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// node是度为1的节点</span></span><br><span class="line">        <span class="comment">// 将要接替node节点的节点replacement的parent指向node的parent</span></span><br><span class="line">        <span class="comment">// 此时，如果再将 node.parent的left或者right指向replacement，就完成了删除node节点的操作</span></span><br><span class="line">        replacement.parent = node.parent;</span><br><span class="line">        <span class="comment">// 更改parent的left、right的指向</span></span><br><span class="line">        <span class="keyword">if</span> (node.parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// node是度为1的节点并且是根节点</span></span><br><span class="line">            root = replacement;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node == node.parent.left) &#123;</span><br><span class="line">            node.parent.left = replacement;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.parent.right = replacement;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// replacement == null 且 node.parent == null，说明node是叶子节点并且是根节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (node.parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        root = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// node是叶子节点，但不是根节点</span></span><br><span class="line">        <span class="keyword">if</span> (node == node.parent.left) &#123;</span><br><span class="line">            node.parent.left = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.parent.right = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉搜索树的复杂度分析"><a href="#二叉搜索树的复杂度分析" class="headerlink" title="二叉搜索树的复杂度分析"></a>二叉搜索树的复杂度分析</h2><p>添加，删除：比较次数跟树的高度有关，O(h) &#x3D;&#x3D;O(logn)，如果是满二叉树，高度的复杂度是 logn 级别的。</p>
<h1 id="平衡二叉搜索树"><a href="#平衡二叉搜索树" class="headerlink" title="平衡二叉搜索树"></a>平衡二叉搜索树</h1><p>平衡的概念：节点数量一定时，左右子树的高度越接近，二叉树就越平衡。(高度越低)</p>
<p>在节点的添加、删除之后，想办法让二叉搜索树恢复平衡，减少树的高度</p>
<h2 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h2><p>Windows NT 内核中广泛使用</p>
<p>平衡因子：某节点左右子树的高度差。</p>
<p>AVL树的特点：</p>
<ul>
<li>每个节点的平衡因子只可能是1、0、-1(绝对值&lt;&#x3D;1，如果超过1，称为失衡)</li>
<li>每个节点的左右子树高度差不超过1</li>
<li>搜搜、添加、删除的时间复杂度是O(logn)</li>
</ul>
<p><img src="https://www.lizhaoloveit.cn/blogArticles/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/media/image-20230405121850819-0668333.png" alt="image-20230405121850819"></p>
<p><img src="https://www.lizhaoloveit.cn/blogArticles/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/media/image-20230405122448400.png" alt="image-20230405122448400"></p>
<p>所以第二个二叉树是 AVL 树</p>
<h3 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h3><p>添加节点可能会导致所有祖先节点都失衡</p>
<p>只要让高度最低的失衡节点恢复平衡，整棵树就恢复平衡，仅需O(1)次调整</p>
<h4 id="LL-右旋转（单旋）"><a href="#LL-右旋转（单旋）" class="headerlink" title="LL-右旋转（单旋）"></a>LL-右旋转（单旋）</h4><p>左左，说明左边高度大，失衡，所以要右旋转</p>
<p><img src="https://www.lizhaoloveit.cn/blogArticles/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/media/image-20230405160555453-0681957.png" alt="image-20230405160555453"></p>
<p>g.left &#x3D; p.right</p>
<p>p.right &#x3D; g</p>
<p>让p成为这颗子树的根节点。</p>
<p>还需要注意的是，T2、p、g的 parent 属性，更新 p 、g 的高度</p>
<h4 id="RR-左旋转"><a href="#RR-左旋转" class="headerlink" title="RR-左旋转"></a>RR-左旋转</h4><p><img src="https://www.lizhaoloveit.cn/blogArticles/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/media/image-20230405131112437.png" alt="image-20230405131112437"></p>
<p>g.right &#x3D; p.left</p>
<p>p.left &#x3D; g</p>
<p>让 p 成为这棵子树的根节点</p>
<h4 id="LR-RR左旋转-gt-LL右旋转-双旋"><a href="#LR-RR左旋转-gt-LL右旋转-双旋" class="headerlink" title="LR-RR左旋转-&gt;LL右旋转(双旋)"></a>LR-RR左旋转-&gt;LL右旋转(双旋)</h4><p><img src="https://www.lizhaoloveit.cn/blogArticles/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/media/image-20230405161129407.png" alt="image-20230405161129407"></p>
<h4 id="RL-LL右旋转-gt-RR左旋转-双旋"><a href="#RL-LL右旋转-gt-RR左旋转-双旋" class="headerlink" title="RL-LL右旋转-&gt;RR左旋转(双旋)"></a>RL-LL右旋转-&gt;RR左旋转(双旋)</h4><p><img src="https://www.lizhaoloveit.cn/blogArticles/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/media/image-20230405161249798.png" alt="image-20230405161249798"></p>
<h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><p>删除节会导致父节点或者祖先节点失衡(只有一个节点会失衡)，其他节点都不可能失衡，但是恢复平衡后，则可能导致更高层的祖先节点失衡，最多需要O(logn)次调整</p>
<blockquote>
<p>如果删除一个节点，会导致父节点失衡，说明删除的是高度比较低的子节点，因此父节点的高度不会变化，所以除父节点外，都不会失衡</p>
</blockquote>
<p><img src="https://www.lizhaoloveit.cn/blogArticles/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/media/image-20230415142055925.png" alt="image-20230415142055925"></p>
<p><img src="https://www.lizhaoloveit.cn/blogArticles/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/media/image-20230415142106385.png" alt="image-20230415142106385"></p>
<h3 id="AVL树的平均时间复杂度"><a href="#AVL树的平均时间复杂度" class="headerlink" title="AVL树的平均时间复杂度"></a>AVL树的平均时间复杂度</h3><p>搜索：O(logn)</p>
<p>添加：O(logn)，需要O(1)次的旋转操作</p>
<p>删除：O(logn)，需要O(logn)次的旋转操作</p>
<h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p>B树是一种平衡的多路搜索树，多叉树，用于文件系统、数据库实现。</p>
<ul>
<li><p>1个节点可以存储超过2个元素，可以拥有超过2个子节点</p>
</li>
<li><p>拥有二叉搜索树的一些性质。</p>
</li>
<li><p>平衡，每个节点的所有子树高度一致</p>
</li>
</ul>
<p><img src="https://www.lizhaoloveit.cn/blogArticles/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/media/image-20230415220312669.png" alt="image-20230415220312669"></p>
<p><img src="https://www.lizhaoloveit.cn/blogArticles/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/media/image-20230415220324205.png" alt="image-20230415220324205"></p>
<h3 id="m阶B树的性质-m-ge-2"><a href="#m阶B树的性质-m-ge-2" class="headerlink" title="m阶B树的性质 m$\ge$2"></a>m阶B树的性质 m$\ge$2</h3><p>$$<br>\begin{matrix}<br>一个树中节点最多拥有m个子节点，被称为m阶B树。\<br>假设一个节点存储的元素个数为x， \<br>若节点为根节点时，1\le x\le m-1，有子节点y：2\le y\le m。 \<br>若节点为非根节点，\lceil m&#x2F;2\rceil -1 \le x\le m-1，有子节点y：\lceil m&#x2F;2\rceil\le y \le m。\<br>比如：m&#x3D;3，{\color{red}2}\le y\le{\color{red}3}，成为(2,3)树、2-3树 \<br>比如：m&#x3D;4，{\color{red}2}\le y\le{\color{red}4}，成为(2,3)树、2-3-4树\<br>比如：m&#x3D;5，{\color{red}3}\le y\le{\color{red}5}，成为(3,5)树 \<br>比如：m&#x3D;6，{\color{red}3}\le y\le{\color{red}6}，成为(3,6)树 \<br>比如：m&#x3D;7，{\color{red}4}\le y\le{\color{red}7}，成为(4,7)树 \<br>\end{matrix}<br>$$</p>
<blockquote>
<p>2阶B树就是二叉搜索树</p>
<p>数据库底层数据存储结构用到了 B 树，一般是200-300阶B树</p>
</blockquote>
<h3 id="B树搜索"><a href="#B树搜索" class="headerlink" title="B树搜索"></a>B树搜索</h3><p><img src="https://www.lizhaoloveit.cn/blogArticles/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/media/image-20230416064620758.png" alt="image-20230416064620758"></p>
<ol>
<li>现在节点内部从小到大开始搜索元素</li>
<li>如果命中，搜索结束</li>
<li>如果没有，再去对应的子节点中搜索元素，重复步骤1</li>
</ol>
<h3 id="B树添加-例子为4阶B树"><a href="#B树添加-例子为4阶B树" class="headerlink" title="B树添加-例子为4阶B树"></a>B树添加-例子为4阶B树</h3><p>新添加的元素必定会添加到叶子节点</p>
<p>上溢：在m阶B树添加节点时，一个节点已经存在m-1个元素，添加时，超出了节点元素的最大值。叫做上溢。overflow</p>
<p><img src="https://www.lizhaoloveit.cn/blogArticles/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/media/image-20230416100502323.png" alt="image-20230416100502323"></p>
<blockquote>
<p>解决上溢问题：假设上溢节点中间位置的元素为k</p>
<p>将 k 位置的元素向上与父节点合并</p>
<p>将[0,k-1]和[k+1,m-1]位置的元素分裂成两个子节点，这两个子节点的元素个数，不会低于最低限制 $\lceil m&#x2F;2 \rceil-1$。</p>
<p>一次分裂完毕后，有可能导致父节点上溢，依然按照上述方法解决，</p>
<p>最极端的情况，一直分裂到根节点</p>
</blockquote>
<h3 id="B树删除-例子为5阶B树"><a href="#B树删除-例子为5阶B树" class="headerlink" title="B树删除-例子为5阶B树"></a>B树删除-例子为5阶B树</h3><p><img src="https://www.lizhaoloveit.cn/blogArticles/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/media/image-20230416101157783.png" alt="image-20230416101157783"></p>
<ul>
<li>删除的元素在叶子节点中，直接删除即可<ul>
<li>删除30</li>
<li><img src="https://www.lizhaoloveit.cn/blogArticles/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/media/image-20230416101215807-1611141.png" alt="image-20230416101215807"></li>
</ul>
</li>
<li>删除的元素在非叶子节点中<ul>
<li>先找到前驱或者后继元素，覆盖所需删除元素的值</li>
<li>再把前驱或者后继元素删除</li>
<li>删除 60</li>
<li><img src="https://www.lizhaoloveit.cn/blogArticles/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/media/image-20230416101336224.png" alt="image-20230416101336224"></li>
<li><img src="https://www.lizhaoloveit.cn/blogArticles/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/media/image-20230416101347540.png" alt="image-20230416101347540"></li>
<li>非叶子节点的前驱或者后继，必定在叶子节点中</li>
</ul>
</li>
</ul>
<p>下溢：叶子节点被删除一个元素后，元素个数可能会低于限制($\ge \lceil m&#x2F;2\rceil -1$)</p>
<p>underflow</p>
<p><img src="https://www.lizhaoloveit.cn/blogArticles/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/media/image-20230416101627360.png" alt="image-20230416101627360"></p>
<p>删除22  元素个数除根节点外，最低为5&#x2F;2 -1&#x3D; 2;</p>
<ul>
<li><p>如果下溢节点临近的兄弟节点，至少有$\lceil m&#x2F;2\rceil$个元素，可以向其借一个元素</p>
<ul>
<li><p><img src="https://www.lizhaoloveit.cn/blogArticles/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/media/image-20230416102518341.png" alt="image-20230416102518341"></p>
</li>
<li><p>将父节点 b 插入到下溢节点的头部(最小元素前面的位置)</p>
</li>
<li><p>用兄弟节点的尾部(最大元素)代替父节点的元素b</p>
</li>
<li><p>这种操作就是旋转：</p>
</li>
<li><p><img src="https://www.lizhaoloveit.cn/blogArticles/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/media/image-20230416102650986.png" alt="image-20230416102650986"></p>
<ul>
<li>此处d，从a的右子节点转变为b的左子节点。原树中b &gt; d &gt; a</li>
</ul>
</li>
</ul>
</li>
<li><p>如果下溢节点临近的兄弟节点，只有$\lceil m&#x2F;2\rceil-1$个元素</p>
<ul>
<li><img src="https://www.lizhaoloveit.cn/blogArticles/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/media/image-20230416102846736.png" alt="image-20230416102846736"></li>
<li>将父节点元素b下移和左右子节点合并</li>
<li>合并后，子节点元素个数&#x3D;$\lceil m&#x2F;2\rceil-1 + \lceil m&#x2F;2\rceil-2 + 1 &#x3D; 2 * \lceil m&#x2F;2\rceil - 2$，不超过$m-1$。</li>
<li>这个操作有可能导致父节点下溢，依然按照上述方法解决，下溢现象会一直往上传播</li>
<li><img src="https://www.lizhaoloveit.cn/blogArticles/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/media/image-20230416103308557.png" alt="image-20230416103308557"></li>
</ul>
</li>
</ul>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>C++ STL(如 map、set)</p>
<p>Java 的 TreeMap、TreeSet、HashMap、HashSet</p>
<p>自平衡的二叉搜索树。</p>
<h3 id="红黑树的特性"><a href="#红黑树的特性" class="headerlink" title="红黑树的特性"></a>红黑树的特性</h3><p><img src="https://www.lizhaoloveit.cn/blogArticles/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/media/image-20230415185050761.png" alt="image-20230415185050761"></p>
<ol>
<li>节点是 Red，或者 Black</li>
<li>根节点规定是 Black</li>
<li>叶子结点(所有的非空节点下，均为null节点，被称为叶子节点)，都是 Black</li>
<li>Red 节点的子节点一定是 Black<ol>
<li>Red 节点的父节点一定是 Black</li>
<li>从根节点到叶子节点所有路径上不会有两个连续的 Red</li>
</ol>
</li>
<li>从任一节点到叶子节点的所有路径都包含数量相同的 Black 节点</li>
</ol>
<h3 id="红黑树的等价变换"><a href="#红黑树的等价变换" class="headerlink" title="红黑树的等价变换"></a>红黑树的等价变换</h3><p>红黑树和4阶B树 (2-3-4树)具有等价性</p>
<p><img src="https://www.lizhaoloveit.cn/blogArticles/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/media/image-20230416230313285.png" alt="image-20230416230313285"></p>
<p><img src="https://www.lizhaoloveit.cn/blogArticles/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/media/image-20230416230322485.png" alt="image-20230416230322485"></p>
<ul>
<li>${\color{black}BLACK}$ 节点与它的 ${\color{red}RED}$ 子节点融合在一起，形成一个4阶B树节点</li>
<li>红黑树的 ${\color{black}BLACK}$ 节点个数与4阶B树的节点总数相等</li>
<li>网上有些教程：用2-3树 与 红黑树类比，是及其不严谨的，2-3树并不能完美匹配红黑树的的所有情况</li>
<li>后面展示的红黑树因空间有限，会省略 NULL 节点</li>
</ul>
<p>parent 父节点，sibling 兄弟节点，uncle parent的兄弟节点</p>
<h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><p>已知：B树种新元素必定添加到叶子节点中</p>
<p>在红黑树添加节点会出现的所有情况如下示例：</p>
<p><img src="https://www.lizhaoloveit.cn/blogArticles/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/media/image-20230418055759400.png" alt="image-20230418055759400"></p>
<p>建议新添加的节点默认为 Red，这样的好处是，可以在添加节点后，依然满足性质1、2、3、5，性质4不一定满足。</p>
<p>以下是添加节点时所有的情况：</p>
<ul>
<li><p>如果添加的是根节点，染成 ${\color{black}BLACK}$ 即可。</p>
</li>
<li><p>上述包含了所有可能出现的情况中，一共有12种节点添加位置的情况。其中4种是满足红黑树性质4的：即 parent 为 ${\color{black}BLACK}$</p>
<ul>
<li><img src="https://www.lizhaoloveit.cn/blogArticles/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/media/image-20230418060312201.png" alt="image-20230418060312201"></li>
<li>此时不用做额外处理，同时有8种情况不满足红黑树的性质4： ${\color{red}RED}$ 的parent一定是 ${\color{black}BLACK}$</li>
</ul>
</li>
<li><p>前4种属于B树节点上溢</p>
<ul>
<li><img src="https://www.lizhaoloveit.cn/blogArticles/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/media/image-20230418060604093.png" alt="image-20230418060604093"></li>
<li>判定条件：uncle 节点是 ${\color{red}RED}$ ，解决方案如下：</li>
<li>将添加节点的 parent、uncle 染成 ${\color{black}BLACK}$ ，并且把 grand 染成 ${\color{red}RED}$ ，然后当做新添加的节点向上合并。重复添加逻辑。示例如下：</li>
<li><img src="https://www.lizhaoloveit.cn/blogArticles/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/media/image-20230418061420255.png" alt="image-20230418061420255"></li>
<li><img src="https://www.lizhaoloveit.cn/blogArticles/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/media/image-20230418061434853.png" alt="image-20230418061434853"></li>
<li><img src="https://www.lizhaoloveit.cn/blogArticles/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/media/image-20230418061449468.png" alt="image-20230418061449468"></li>
</ul>
</li>
<li><p>其他类型为 LL&#x2F;LR&#x2F;RL&#x2F;RR 型</p>
<ul>
<li>判定条件：uncle 不是 ${\color{red}RED}$ ，其中 LL&#x2F;RR型解决方案如下：</li>
<li><img src="https://www.lizhaoloveit.cn/blogArticles/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/media/image-20230418061740160.png" alt="image-20230418061740160"></li>
<li>将添加节点的 parent 染成 ${\color{black}BLACK}$ ，grand 染成 ${\color{red}RED}$ ，对 grand 进行单旋操作，其中LL型是图最右边添加的节点，grand节点右旋转，RR型是图中靠左的节点，grand节点左旋转</li>
<li>LR&#x2F;RL型解决方案如下：</li>
<li><img src="https://www.lizhaoloveit.cn/blogArticles/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/media/image-20230418062056898.png" alt="image-20230418062056898"></li>
<li>将添加的节点染成 ${\color{black}BLACK}$ ，grand 染成 ${\color{red}RED}$ ，进行双旋操作，其中LR型是图中最右的节点，parent 左旋转，然后 grand 右旋转。RL型是图中靠左的节点，parent 右旋转，然后 grand 左旋转。</li>
</ul>
</li>
</ul>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>在B树种，最后真正被删除的元素都在叶子节点中，具体情况有以下几种</p>
<p><img src="https://www.lizhaoloveit.cn/blogArticles/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/media/image-20230418141151884.png" alt="image-20230418141151884"></p>
<ul>
<li><p>直接删除 ${\color{red}RED}$ 节点，不用做任何调整</p>
</li>
<li><p>删除拥有2个 ${\color{red}RED}$ 节点的 ${\color{black}BLACK}$ ，比如图中的25，由于 BinarySearchTree 的特性，会将其前驱或者后继节点的值赋给图中25节点的位置，所以图中25节点不会被直接删除，因此不用考虑该情况。</p>
</li>
<li><p>拥有1个 ${\color{red}RED}$ 子节点的 ${\color{black}BLACK}$ 节点</p>
<ul>
<li><img src="https://www.lizhaoloveit.cn/blogArticles/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/media/image-20230418143930592.png" alt="image-20230418143930592"></li>
<li>如果度为1，找到 ${\color{red}RED}$ 取代他，判定条件：用以替代的子节点是 ${\color{red}RED}$ ，解决方案：将代替的子节点染成 ${\color{black}BLACK}$ 即可保持红黑树性质。</li>
<li>如果度为0，判定条件：用以替代的子节点是 ${\color{black}BLACK}$ ，这种情况是比较复杂的，因为会导致B树节点下溢，比如删除88<ul>
<li>第一种情况，sibling是 ${\color{black}BLACK}$ <ul>
<li>sibling至少有一个 ${\color{red}RED}$ 子节点。<ul>
<li><img src="https://www.lizhaoloveit.cn/blogArticles/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/media/image-20230419000350693.png" alt="image-20230419000350693"></li>
<li>此时，应该进行旋转操作，图一，删除88，变为LR，先对76左旋，然后对80右旋。图二，删除88，变为LL，对76进行右旋。图三中，删除88后，既可以看成 80,76,78的LR型，也可以看成 80,76,72的LL型，这里为了方便，当成LL型，即对80节点进行右旋转即可。</li>
<li>图一与图二、图三的判断依据：图一的sibling.left是null，也就是sibling.left是 ${\color{black}BLACK}$ </li>
<li>旋转之后，中心节点应改为删除节点parent 的颜色，左右节点染色    ${\color{black}BLACK}$ 。</li>
</ul>
</li>
<li>sibling没有一个 ${\color{red}RED}$ 子节点。<ul>
<li><img src="https://www.lizhaoloveit.cn/blogArticles/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/media/image-20230419004814927.png" alt="image-20230419004814927"></li>
<li>图一情况：parent 是 ${\color{red}RED}$ ，将 sibling 染色 ${\color{red}RED}$ ，将 parent 染色 ${\color{black}BLACK}$ 。也就是4阶B树的节点下溢。</li>
<li>图二情况：parent 是 ${\color{black}BLACK}$ ，会导致 grand 下溢，这时，只需要把 parent 当做被删除的节点处理即可（递归）。</li>
</ul>
</li>
</ul>
</li>
<li>第二种情况，sibling是 ${\color{red}RED}$ <ul>
<li><img src="https://www.lizhaoloveit.cn/blogArticles/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/media/image-20230419005905112.png" alt="image-20230419005905112"></li>
<li>思路：想办法让 sibling（55） 变成 ${\color{black}BLACK}$ ，将parent（80）右旋，将 sibling（55） 染成 ${\color{black}BLACK}$ ，parent（80） 染成 ${\color{red}RED}$ 。</li>
<li><img src="https://www.lizhaoloveit.cn/blogArticles/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/media/image-20230419024210335.png" alt="image-20230419024210335"></li>
<li>就变成了 sibling 为 ${\color{black}BLACK}$ 的情况，按照之前的情况处理：</li>
<li><img src="https://www.lizhaoloveit.cn/blogArticles/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/media/image-20230419024453756.png" alt="image-20230419024453756"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="思考：代码中的afterRemove方法，可以只传一个参数"><a href="#思考：代码中的afterRemove方法，可以只传一个参数" class="headerlink" title="思考：代码中的afterRemove方法，可以只传一个参数"></a>思考：代码中的afterRemove方法，可以只传一个参数</h4><p>具体做法，把 replacement 参数删除，然后再度为1的时候，不传node，传replacement即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    size--;</span><br><span class="line">    <span class="comment">// 度为2的节点</span></span><br><span class="line">    <span class="keyword">if</span> (node.hasTwoChildren()) &#123;</span><br><span class="line">        <span class="comment">// 找到后继节点</span></span><br><span class="line">        TreeNode&lt;E&gt; s = successor(node);</span><br><span class="line">        <span class="comment">// 用后继节点的值覆盖度为2的节点的值</span></span><br><span class="line">        node.val = s.val;</span><br><span class="line">        <span class="comment">// 删除后继节点，</span></span><br><span class="line">        node = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除node节点(node的度必然是1或者0)</span></span><br><span class="line">    TreeNode&lt;E&gt; replacement = node.left != <span class="keyword">null</span> ? node.left : node.right;</span><br><span class="line">    <span class="keyword">if</span> (replacement != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// node是度为1的节点</span></span><br><span class="line">        <span class="comment">// 将要接替node节点的节点replacement的parent指向node的parent</span></span><br><span class="line">        <span class="comment">// 此时，如果再将 node.parent的left或者right指向replacement，就完成了删除node节点的操作</span></span><br><span class="line">        replacement.parent = node.parent;</span><br><span class="line">        <span class="comment">// 更改parent的left、right的指向</span></span><br><span class="line">        <span class="keyword">if</span> (node.parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// node是度为1的节点并且是根节点</span></span><br><span class="line">            root = replacement;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node == node.parent.left) &#123;</span><br><span class="line">            node.parent.left = replacement;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.parent.right = replacement;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除节点之后的调整</span></span><br><span class="line">        afterRemove(replacement);              <span class="comment">// &lt;-----这里改一下</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// replacement == null 且 node.parent == null，说明node是叶子节点并且是根节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (node.parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        root = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 删除节点之后的调整</span></span><br><span class="line">        afterRemove(node);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// node是叶子节点，但不是根节点</span></span><br><span class="line">        <span class="keyword">if</span> (node == node.parent.left) &#123;</span><br><span class="line">            node.parent.left = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.parent.right = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除节点之后的调整</span></span><br><span class="line">        afterRemove(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在红黑树中，将</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果要删除的节点是红色，什么也不做</span></span><br><span class="line"><span class="keyword">if</span> (isRed(node)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果删除的是黑色且度为1的节点，用子节点替代，子节点必然是红色，将其染色黑色即可</span></span><br><span class="line"><span class="keyword">if</span> (isRed(replacement)) &#123;</span><br><span class="line">    black(replacement);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码合并</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果删除的是黑色且度为1的节点，用子节点替代，子节点必然是红色，将其染色黑色即可</span></span><br><span class="line"><span class="comment">// 如果删除的是叶子节点，且为红色，染黑再删除</span></span><br><span class="line"><span class="keyword">if</span> (isRed(replacement)) &#123;</span><br><span class="line">    black(replacement);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行结果不会改变。</p>
<p><a href="https://gitee.com/Ammar/algorithm" target="_blank" rel="noopener">代码仓库</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Ammar</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://lizhaoloveit.cn/2019/06/23/%E6%A0%91/">http://lizhaoloveit.cn/2019/06/23/%E6%A0%91/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://lizhaoloveit.cn">Ammar's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法    </a></div><div class="post_share"><div class="social-share" data-image="https://lizhaoloveit.cn/blogimages/blog/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-buttom"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lozad post-qr-code__img" data-src="/img/wechat.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lozad post-qr-code__img" data-src="/img/alipay.jpg"><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull-left"><a href="/2019/06/26/%E5%8F%8D%E5%B0%84/"><img class="prev_cover lozad" data-src="https://www.lizhaoloveit.cn/blogimages/blog/cover/1.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/2.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/3.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/4.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/5.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/6.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/7.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/8.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/9.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/10.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/11.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/12.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/13.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/14.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/15.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/16.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/17.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/18.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/19.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/20.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/21.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/22.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/23.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/24.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/25.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/26.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/27.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/28.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/29.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/31.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/32.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/33.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/34.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/35.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/36.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/37.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/38.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/39.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/40.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/41.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/42.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/43.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/44.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/45.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/46.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/47.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/48.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/49.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/50.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/51.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/52.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/53.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/54.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/55.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/56.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/57.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/58.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/59.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/60.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/62.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/63.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/64.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/65.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/66.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/67.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/68.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/69.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/70.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/71.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/72.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/73.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/74.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/75.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/76.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/77.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/78.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/79.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>反射</span></div></a></div><div class="next-post pull-right"><a href="/2019/06/19/HashMap%E5%BA%95%E5%B1%82%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0/"><img class="next_cover lozad" data-src="https://www.lizhaoloveit.cn/blogimages/blog/cover/1.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/2.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/3.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/4.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/5.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/6.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/7.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/8.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/9.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/10.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/11.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/12.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/13.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/14.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/15.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/16.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/17.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/18.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/19.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/20.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/21.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/22.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/23.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/24.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/25.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/26.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/27.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/28.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/29.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/31.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/32.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/33.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/34.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/35.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/36.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/37.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/38.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/39.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/40.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/41.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/42.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/43.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/44.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/45.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/46.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/47.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/48.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/49.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/50.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/51.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/52.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/53.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/54.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/55.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/56.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/57.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/58.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/59.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/60.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/62.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/63.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/64.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/65.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/66.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/67.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/68.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/69.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/70.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/71.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/72.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/73.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/74.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/75.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/76.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/77.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/78.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/79.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>HashMap底层设计实现</span></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i> <span>评论</span></div><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'http://lizhaoloveit.cn/2019/06/23/%E6%A0%91/';
  this.page.identifier = '2019/06/23/树/';
  this.page.title = '树';
}
var d = document, s = d.createElement('script');
s.src = "https://" + 'lizhao' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script></div></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2014 - 2024 By Ammar</div><div class="icp"><a href="https://beian.miit.gov.cn/" target="_blank" rel="noopener"><span>浙ICP备19013619号-1</span></a></div><div class="bag"><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=33010502006128" target="_blank" rel="noopener"><img src="/img/beian.png"><span>浙公网安备 33010502006128号</span></a></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><section class="rightside" id="rightside"><i class="fa fa-book" id="readmode" title="阅读模式"> </i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换">繁</a><i class="far fa-moon nightshift" id="nightshift" title="夜间模式"></i></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script async src="/js/search/algolia.js"></script><script src="/js/nightshift.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()

</script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><!-- hexo-inject:begin --><!-- hexo-inject:end --></body></html>