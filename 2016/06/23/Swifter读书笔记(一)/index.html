<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>Swifter 读书笔记(一) | Ammar's Blog</title><meta name="description" content="Swifter 读书笔记(一)"><meta name="keywords" content="Swift"><meta name="author" content="Ammar"><meta name="copyright" content="Ammar"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.11.1/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="http://lizhaoloveit.cn/2016/06/23/Swifter%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(%E4%B8%80)/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="Swifter 读书笔记(一)"><meta name="twitter:description" content="Swifter 读书笔记(一)"><meta name="twitter:image" content="https://lizhaoloveit.cn/blogimages/blog/avatar.jpg"><meta property="og:type" content="article"><meta property="og:title" content="Swifter 读书笔记(一)"><meta property="og:url" content="http://lizhaoloveit.cn/2016/06/23/Swifter%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(%E4%B8%80)/"><meta property="og:site_name" content="Ammar's Blog"><meta property="og:description" content="Swifter 读书笔记(一)"><meta property="og:image" content="https://lizhaoloveit.cn/blogimages/blog/avatar.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="prev" title="Swifter 读书笔记(二)" href="http://lizhaoloveit.cn/2016/06/27/Swifter%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(%E4%BA%8C)/"><link rel="next" title="Swift FMDB" href="http://lizhaoloveit.cn/2016/06/01/Swift-FMDB/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?162506e75ffd64287398566b2f5738c8";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"VRMKRAV9AT","apiKey":"bd7157400046d0f02396708a501a3480","indexName":"lizhaoloveit","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"cookieDomain":"https://lizhaoloveit.cn/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: '添加书签',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天'

  
}</script><meta name="generator" content="Hexo 4.2.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Currying-柯里化"><span class="toc-number">1.</span> <span class="toc-text">Currying 柯里化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Struct-Mutable-的方法"><span class="toc-number">2.</span> <span class="toc-text">Struct Mutable 的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#将-protocol-的方法声明为-mutating"><span class="toc-number">2.1.</span> <span class="toc-text">将 protocol 的方法声明为 mutating</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Sequence-…-关联"><span class="toc-number">3.</span> <span class="toc-text">Sequence … 关联</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#多元祖-Tuple"><span class="toc-number">4.</span> <span class="toc-text">多元祖 Tuple</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#autoclosure-和"><span class="toc-number">5.</span> <span class="toc-text">@autoclosure 和 ??</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Optional-Chaining-可选链"><span class="toc-number">6.</span> <span class="toc-text">Optional Chaining(可选链)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#操作符"><span class="toc-number">7.</span> <span class="toc-text">操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#infix"><span class="toc-number">7.0.1.</span> <span class="toc-text">infix</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#associativity"><span class="toc-number">7.0.2.</span> <span class="toc-text">associativity</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#precedence-优先权"><span class="toc-number">7.0.3.</span> <span class="toc-text">precedence(优先权)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#func-的参数修饰"><span class="toc-number">8.</span> <span class="toc-text">func 的参数修饰</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字面转换量"><span class="toc-number">9.</span> <span class="toc-text">字面转换量</span></a></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://lizhaoloveit.cn/blogimages/blog/top_img.jpg)"><div id="page-header"><span class="pull-left"> <a class="blog_title" id="site-name" href="/">Ammar's Blog</a></span><div class="open toggle-menu pull-right"><div class="menu-icon-first"></div><div class="menu-icon-second"></div><div class="menu-icon-third"></div></div><span class="pull-right menus"><div class="mobile_author_icon"><img class="lozad" data-src="https://lizhaoloveit.cn/blogimages/blog/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'"><div class="mobile_author-info__description">微信号：aicjaish</div></div><hr><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a><a class="site-page" href="/comment/"><i class="fa-fw fa fa-coffee"></i><span> 留言</span></a><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title"><div class="posttitle">Swifter 读书笔记(一)</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2016-06-23<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2019-07-27</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Swift/">Swift</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Swift/Swift%E5%9F%BA%E7%A1%80/">Swift基础</a></span><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">3.9k</span><span class="post-meta__separator">|</span><span>阅读时长: 15 分钟</span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="Currying-柯里化"><a href="#Currying-柯里化" class="headerlink" title="Currying 柯里化"></a>Currying 柯里化</h1><p>Swift 里可以将方法进行柯里化，把接受多个参数的方法转变成接受第一个参数的方法，并且返回 一个接受其余参数并且返回结果的新方法。</p>
<p>curry 是 Swift 中一个很灵活的特性，curry 就是一个用方法生成方法的机制。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a: Int, b:Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>, b: <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> numbers = <span class="number">1</span>...<span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> added = numbers.<span class="built_in">map</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> add($<span class="number">0</span>, b: <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a: Int)</span></span> -&gt; (<span class="type">Int</span> -&gt; <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        b <span class="keyword">in</span> <span class="keyword">return</span> a + b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> added1 = numbers.<span class="built_in">map</span>(add(<span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<p>向上面的代码那样，给 add 函数传入不同参数，它就会依照这个参数值生成一个新的函数，这个就会对它接受的参数与之前 add 指定的的增量进行加法操作。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a: Int)</span></span>(b: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先传入2 则 返回一个 2 + b -&gt; Int 的函数 b 为传入参数。</span></span><br><span class="line"><span class="keyword">let</span> addTwo = add(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>上面我们对自定义方法进行 curry 处理，那么如果系统内置的方法，或者别的第三方库中定义的方法，如何对他们应用 curry</p>
<p>例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义方法进行 curry 处理，那么如果系统内置的方法，或者别的第三方库中定义的方法，如果使用对他们应用 curry</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给 NSNumber 定义一个 multiple 方法</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSNumber</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">multiple</span>(<span class="title">left</span>: <span class="title">Int</span>, <span class="title">right</span>: <span class="title">Int</span>) -&gt; <span class="title">Int</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">left</span> * <span class="keyword">right</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">add</span>(<span class="title">left</span>: <span class="title">Double</span>, <span class="title">right</span>: <span class="title">Double</span>) -&gt; <span class="title">Double</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">left</span> + <span class="keyword">right</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a: Int, b:Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a: Int)</span></span> -&gt; (<span class="type">Int</span> -&gt; <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        b <span class="keyword">in</span> <span class="keyword">return</span> a + b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不改变这个方法的定义，怎样让它支持 curry 特性</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">curry</span>&lt;A, B, C&gt;<span class="params">(function: <span class="params">(A, B)</span></span></span> -&gt; <span class="type">C</span>) -&gt; (<span class="type">A</span> -&gt; (<span class="type">B</span> -&gt; <span class="type">C</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        a <span class="keyword">in</span> &#123;</span><br><span class="line">            b <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">return</span> function(a, b)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, b: <span class="number">2</span>)</span><br><span class="line"><span class="keyword">let</span> numbers = <span class="number">1</span>...<span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> added = numbers.<span class="built_in">map</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> add($<span class="number">0</span>, b: <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> added1 = numbers.<span class="built_in">map</span>(add(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 首先，curry 接受的参数类型为(Int, Int) -&gt; Int 这个表示的是接受两个 Int 类型的参数，</span></span><br><span class="line"><span class="comment"> * 并返回一个 Int 类型。也就是我们在 NSNumber 扩展中定义的 multiple 函数类型。我们可以</span></span><br><span class="line"><span class="comment"> * 将 Number.multiple 作为参数传给这个方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// curry 这个函数，会把传给它的函数转换成另一个带有 currying 特性的函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> curriedMultiple = curry(<span class="type">NSNumber</span>.multiple)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = curriedMultiple(<span class="number">3</span>)(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">let</span> b = curry(<span class="type">NSNumber</span>.add)(<span class="number">3.0</span>)(<span class="number">3.0</span>)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>

<h1 id="Struct-Mutable-的方法"><a href="#Struct-Mutable-的方法" class="headerlink" title="Struct Mutable 的方法"></a>Struct Mutable 的方法</h1><p>在 Swift 中我们基本都是用 struct 去定义一个纯数据类型。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">	<span class="keyword">var</span> weight: <span class="type">Int</span></span><br><span class="line">	<span class="keyword">var</span> height: <span class="type">Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在变量里添加一些简单的改变变量里内容的方法</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Struct 出来的变量是 Immutable 的，不可改变的。想要用一个方法去改变变量里面的值，就需要加上一个关键字 mutating，User 的 Weight 是 Immutable 的，所以 += 无法再这两个 Int 上使用</span></span><br><span class="line"><span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">gainWeight</span><span class="params">(newWeight: Int)</span></span> &#123;</span><br><span class="line">	weight += newWeight</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="将-protocol-的方法声明为-mutating"><a href="#将-protocol-的方法声明为-mutating" class="headerlink" title="将 protocol 的方法声明为 mutating"></a>将 protocol 的方法声明为 mutating</h2><p>Swift 的 protocol 不仅可以被 class 类型实现，也适用于 struct 和 enum。</p>
<p>在写给别人用的接口时，需要考虑是否使用 mutating 来修饰方法，Swift 的 mutating 关键字修饰方法，是为了能在该方法中修改 struct 或者 enum 的变量。比如下面代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> numberOfWheels: <span class="type">Int</span>&#123;<span class="keyword">get</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> color: <span class="type">UIColor</span> &#123;<span class="keyword">get</span> <span class="keyword">set</span>&#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">changeColor</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyCar</span>: <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> numberOfWheels = <span class="number">4</span></span><br><span class="line">    <span class="keyword">var</span> color = <span class="type">UIColor</span>.blueColor()</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">changeColor</span><span class="params">()</span></span> &#123;</span><br><span class="line">        color = <span class="type">UIColor</span>.redColor()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用 class 来实现带有 mutating 的方法的接口时，具体实现的前面是不需要加 mutating 修饰的，因为 class 可以随意更改自己的成员变量。所以在接口里用 mutating 修饰方法，对于 class 的实现是完全透明，可以当作不存在的。</p>
<h1 id="Sequence-…-关联"><a href="#Sequence-…-关联" class="headerlink" title="Sequence … 关联"></a>Sequence … 关联</h1><p>Swift 的 for…in 可以用在所有实现了 SequenceType 的类型上。</p>
<p>首先需要实现 GeneratorType。比如一个实现了反向的 generator 和 sequence 可以这么写：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先定义一个实现了 GeneratorType protocol 的类型</span></span><br><span class="line"><span class="comment">// GeneratorType 需要制定一个 typealias Element</span></span><br><span class="line"><span class="comment">// 以及提供一个返回 Element? 的方法 next()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// reverse 反转</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReverseGenerator</span>: <span class="title">GeneratorType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Element</span> = <span class="type">Int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> counter: <span class="type">Element</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>&lt;<span class="type">T</span>&gt;(array: [<span class="type">T</span>]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.counter = array.<span class="built_in">count</span> - <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(start: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.counter = start</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">Element?</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> counter &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        counter -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> counter + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后我们来定义 SequenceType</span></span><br><span class="line"><span class="comment">// 和 GeneratorType 很类似，不过换成指定一个 typealias Generator</span></span><br><span class="line"><span class="comment">// 以及提供一个返回 Generator?的方法 generate()</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ReverseSequence</span>&lt;<span class="title">T</span>&gt;: <span class="title">SequenceType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> array: [<span class="type">T</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(array: [<span class="type">T</span>]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.array = array</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Generator</span> = <span class="type">ReverseGenerator</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">generate</span><span class="params">()</span></span> -&gt; <span class="type">Generator</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ReverseGenerator</span>(array: array)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对 SequenceType 可以使用 for...in来循环访问</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//for i in ReverseSequence(array: arr) &#123;</span></span><br><span class="line"><span class="comment">//    print("Index\(i) is \(arr[i])")</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for in 这样的方法到底做了什么</span></span><br><span class="line"><span class="keyword">var</span> ar = <span class="type">ReverseSequence</span>(array: arr)</span><br><span class="line"><span class="keyword">var</span> g = <span class="type">ReverseSequence</span>(array: arr).generate()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">let</span> obj = g.next() &#123;</span><br><span class="line">    <span class="built_in">print</span>(obj)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顺便你可以使用 map， filter，和 reduce 这些方法，接口扩展实现了他们</span></span><br></pre></td></tr></table></figure>

<h1 id="多元祖-Tuple"><a href="#多元祖-Tuple" class="headerlink" title="多元祖 Tuple"></a>多元祖 Tuple</h1><p>使用多元组，会让程序轻松不少，比如交换输入：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapMe</span>&lt;T&gt;<span class="params">(<span class="keyword">inout</span> a: T, <span class="keyword">inout</span> b: T)</span></span>&#123;</span><br><span class="line">	<span class="keyword">let</span> temp = a</span><br><span class="line">	a = b</span><br><span class="line">	b = temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用多元祖：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapMe</span>&lt;T&gt;<span class="params">(<span class="keyword">inout</span> a: T, <span class="keyword">inout</span> b: T)</span></span>&#123;</span><br><span class="line">	(a,b) = (b,a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OC 中 CGRect 有一个辅助方法叫做 CGRectDivide 用来将一个 CGRect 在一定位置切分成两个区域。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// CGRectDivide(CGRect rect, CGRect *slice, CGRect *remainder, CGFloat amount, CGRectEdge dge</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">CGRect rect = CGRectMake(0, 0, 100, 100)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">CGRect small</span></span><br><span class="line"><span class="comment">CGRect large</span></span><br><span class="line"><span class="comment">CGRectDivide(rect, &amp;small, &amp;large, 20, CGRectMinXEdge)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 Swift 中，使用了多元组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// func rectsByDividing(atDistance: CGFloat, fromEdge: CGRectEdge)</span></span><br><span class="line"><span class="comment">//    -&gt; (slice: CGRect, remainder: CGRect)</span></span><br><span class="line"><span class="keyword">let</span> rect = <span class="type">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> (small, large) = rect.divide(<span class="number">20</span>, fromEdge: .<span class="type">MinXEdge</span>)</span><br></pre></td></tr></table></figure>

<h1 id="autoclosure-和"><a href="#autoclosure-和" class="headerlink" title="@autoclosure 和 ??"></a>@autoclosure 和 ??</h1><p>@autoclosure 做的事情就是把一句表达式自动地封装成一个闭包。</p>
<p>例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">logIfTrue</span><span class="params">(predicate: <span class="params">()</span></span></span> -&gt; <span class="type">Bool</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> predicate() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"True"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行：</span></span><br><span class="line">logIfTrue(&#123;<span class="keyword">return</span> <span class="number">2</span> &gt; <span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 swift 中对闭包的用法可以进行一些简化</span></span><br><span class="line">logIfTrue(&#123;<span class="number">2</span> &gt; <span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还可以更近一步简化，闭包是最后一个参数</span></span><br><span class="line">logIfTrue&#123;</span><br><span class="line">    <span class="number">2</span> &gt; <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">logIfTrue</span><span class="params">(@autoclosure predicate:<span class="params">()</span></span></span> -&gt; <span class="type">Bool</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> predicate() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"True"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这时候我们就可以直接写：</span></span><br><span class="line">logIfTrue(<span class="number">2</span> &gt; <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>Swift 会把 2 &gt; 1这个表达式自动转换为 () -&gt; Bool。</p>
<p>在 Swift 中，有一个非常有用的操作符，可以快速的对 nil 进行判断，??</p>
<p>这个操作符可以判断输入并在当左侧的值是非 nil 的 Optional 值时返回其 value，当左侧是 nil 时返回右侧的值，比如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> level: <span class="type">Int?</span></span><br><span class="line"><span class="keyword">var</span> startLevel = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> currentLevel = level ?? startLevel</span><br></pre></td></tr></table></figure>

<p>因此最后 一个 startLevel 被赋值给了 currentLevel ，??的定义：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> ??&lt;T&gt;<span class="params">(<span class="keyword">optional</span>: T?, @autoclosure defaultValue:<span class="params">()</span></span></span> -&gt; <span class="type">T?</span>) -&gt; <span class="type">T?</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> ??&lt;T&gt;<span class="params">(<span class="keyword">optional</span>: T?, @autoclosure defaultValue:<span class="params">()</span></span></span> -&gt; <span class="type">T</span>) -&gt; <span class="type">T</span></span><br></pre></td></tr></table></figure>

<p>这里我们输入满足的是后者，虽然表面上看，startLevel 只是一个 Int，其实它被自动封装成了一个() -&gt; Int，实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> ??&lt;T&gt;<span class="params">(<span class="keyword">optional</span>: T?, @autoclosure defaultValue:<span class="params">()</span></span></span> -&gt; <span class="type">T</span>) -&gt; <span class="type">T</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">switch</span> <span class="keyword">optional</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> .<span class="type">Some</span>(<span class="keyword">let</span> value):</span><br><span class="line">			<span class="keyword">return</span> value</span><br><span class="line">		<span class="keyword">case</span> .<span class="type">None</span>:</span><br><span class="line">		<span class="keyword">return</span> defaultValue()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们直接使用 T，那么久以为这 在 ?? 操作符真正取值之前，我们就必须准备好一个默认值。这个默认值的准备和计算是会消耗性能的。但是其实要是 optional 不是 nil 的话，我们是完全不需要这个默认值的，而会直接返回 optional 解包后的值。这样一来，默认值就拜拜准备了。这样的开销是完全可以避免的，方法就是讲默认值的计算推迟到了 optional 判定为 nil 之后。</p>
<p>@autoclosure 并不支持带有输入参数的写法，只有形如() -&gt; T 的参数才能使用这个特性进行简化，另外因为调用者往往很容易忽视 @autoclosure 这个特性，需要小心使用，还是写完整的闭包写法比较好。</p>
<p>练习：其实 &amp;&amp; 和 || 这两个操作符里也用到了 @autoclosure，试试看如何实现这两个操作符</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// false &amp;&amp; true -&gt; false true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> &amp;&amp;<span class="params">(@autoclosure predicate1: <span class="params">()</span></span></span> -&gt; <span class="type">Bool</span>, <span class="meta">@autoclosure</span> predicate2: () -&gt; <span class="type">Bool</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> predicate1() <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">guard</span> predicate2() <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> ||<span class="params">(@autoclosure predicate1: <span class="params">()</span></span></span> -&gt; <span class="type">Bool</span>, <span class="meta">@autoclosure</span> predicate2: () -&gt; <span class="type">Bool</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> predicate1() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> predicate2() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Optional-Chaining-可选链"><a href="#Optional-Chaining-可选链" class="headerlink" title="Optional Chaining(可选链)"></a>Optional Chaining(可选链)</h1><p>使用 Optional Chaining 可以让我们摆脱很多不必要的判断和取值，但是需要注意一些陷阱</p>
<p>因为 Optional Chaining 是随时都可能体检返回 nil 的，所以使用 Optional Chaining 所得到的东西其实都是 Optional 的，比如有下面的一段代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Toy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> toy: <span class="type">Toy?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> pet: <span class="type">Pet?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们想通过小明，知道小明的宠物的玩具的名字，则：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xiaoming = <span class="type">Child</span>()</span><br><span class="line"><span class="keyword">let</span> toyName = xiaoming.pet?.toy?.name</span><br></pre></td></tr></table></figure>
<p>在这个 Optional Chaining 中，我们在任何一个 ?.时，都可能遇到 nil 而提前返回。</p>
<p>实际使用中，大多情况下我们更希望使用可选绑定来直接取值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> toyname = xiaoming.pet?.toy?.name&#123;</span><br><span class="line">    <span class="comment">// 太好了，小明既有个宠物，而且宠物还正好有个玩具</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，稍微和其他特性结合，事情就会变得复杂起来：</p>
<p>如果为 Toy 定义一个扩展，增加一个玩玩具的 play()方法</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Toy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">play</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时，处于对代码的扩展性，也许会有其他人有一个宠物，宠物会有玩具，玩具有 play()方法，则做一个闭包方便调用</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> playClosure = &#123;(child: <span class="type">Child</span>) -&gt; () <span class="keyword">in</span> child.pet?.toy?.play()&#125;</span><br></pre></td></tr></table></figure>

<p>这样的代码没有意义，在对于 play()的调用上，定义时我们没有写 play()的返回，表示该方法返回 Void，经过 Optional Chaining 我们得到的是一个 Optional 的结果，就是说，最后应该是这样一个 closure:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> playClosure = &#123;(child: <span class="type">Child</span>) -&gt; ()? <span class="keyword">in</span> child.pet?.toy?.play()&#125;</span><br></pre></td></tr></table></figure>

<p>这样调用的返回将是一个() ? 这时候就可以通过可选绑定来判断方法是否被调用成功了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> result: () = playClosure(xiaoming) &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"好开心~"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"没有玩具可以玩"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h1><p>与 Objective-C 不同，Swift 支持重载操作符这样的特性，比如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vector2D</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> y = <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个 Vector2D 相加：</span></span><br><span class="line"><span class="keyword">let</span> v1 = <span class="type">Vector2D</span>(x: <span class="number">2.0</span>, y: <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">let</span> v2 = <span class="type">Vector2D</span>(x: <span class="number">1.0</span>, y: <span class="number">4.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载加号操作符</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> +<span class="params">(<span class="keyword">left</span>: Vector2D, <span class="keyword">right</span>: Vector2D)</span></span> -&gt; <span class="type">Vector2D</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Vector2D</span>(x: <span class="keyword">left</span>.x + <span class="keyword">right</span>.x, y: <span class="keyword">left</span>.y + <span class="keyword">right</span>.y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> v4 = v1 + v2</span><br></pre></td></tr></table></figure>

<p>上面定义的加号，减号，负号等都是存在于 Swift 中的运算符了，我们所做的只是变换它参数进行重载。<br>如果我们要定义一个全新的运算符，需要做的事情会多一件，根据定义选取+*运算符：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> +*<span class="params">(<span class="keyword">left</span>: Vector2D, <span class="keyword">right</span>: Vector2D)</span></span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">left</span>.x * <span class="keyword">right</span>.x + <span class="keyword">left</span>.y * <span class="keyword">right</span>.y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是编译器会报出错误：Operator implementation without matching operator declaration</p>
<p>这时因为，我们没有对这个操作符进行申明。之前可以直接重载 + - * % 是因为 Swift 中早已经有定义了。</p>
<p>这时，我们需要告诉编译器这个符号是一个操作符：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> +* &#123;</span><br><span class="line">    <span class="keyword">associativity</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">precedence</span> <span class="number">160</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="infix"><a href="#infix" class="headerlink" title="infix"></a>infix</h3><p>表示要定义一个中位操作符，即前后都是输入，其他的修饰符还包括，prefix 和 postfix</p>
<h3 id="associativity"><a href="#associativity" class="headerlink" title="associativity"></a>associativity</h3><p>定义了结合律，即如果多个同类的操作符顺序出现的计算顺序，常见的+ - 都是 left，多个加法同时出现，按照从左往右顺序计算。点乘的结果是一个 Double 不会再和其他点乘结合使用，所以这里写 none</p>
<h3 id="precedence-优先权"><a href="#precedence-优先权" class="headerlink" title="precedence(优先权)"></a>precedence(优先权)</h3><p>运算的优先级，越高则优先进行计算。 乘除150 加减140 这里我们定义的是160</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = v1 +* v2</span><br><span class="line"><span class="comment">// 输出14.0</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意点：Swift 的操作符是不能定义在局部域中的，因为至少会希望在全局范围使用你的操作符，否则操作符就失去了意义。不同 module 的操作符是有可能冲突的，这对于库开发者来说是需要特别注意的地方。 如果库中的操作符冲突的话，使用者是无法像解决类型名冲突那样通过指定库名字来进行调用的。因此在重载或者自定义操作符时，应当尽量将其作为其他某个方法的“简便写法”，我们不应该滥用这个特性。</p>
</blockquote>
<h1 id="func-的参数修饰"><a href="#func-的参数修饰" class="headerlink" title="func 的参数修饰"></a>func 的参数修饰</h1><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incrementor</span><span class="params">(variable: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> variable + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用以前 C 的写法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//func incrementor(variable: Int) -&gt; Int &#123;</span></span><br><span class="line"><span class="comment">//    return ++variable</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误的，由于 Swift 默认该参数是 let，而++则说明这是个变量，</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incrementor</span><span class="params">(<span class="keyword">var</span> variable: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ++variable</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> luckyNumber = <span class="number">7</span></span><br><span class="line"><span class="keyword">let</span> newNumber = incrementor(luckyNumber)</span><br><span class="line"></span><br><span class="line"><span class="comment">// newNumber = 8 luckyNumber = 7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正如上面的例子，将参数写作 var 后，var 只在方法内部起作用，不直接影响输入的值，如果希望在方法内部直接修改输入的值，使用 inout</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incrementor</span><span class="params">(<span class="keyword">inout</span> variable: Int)</span></span> &#123;</span><br><span class="line">    ++variable</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newNumber1 = incrementor(&amp;luckyNumber)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(luckyNumber)</span><br></pre></td></tr></table></figure>

<p>最后，要注意参数的修饰是具有传递限制的，对于跨越层级的调用，需要保证同一参数的修饰是统一的。例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeIncrementor</span><span class="params">(addNumber: Int)</span></span> -&gt; ((<span class="keyword">inout</span> <span class="type">Int</span>) -&gt; ()) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">incrementor</span><span class="params">(<span class="keyword">inout</span> variable: Int)</span></span> -&gt; () &#123;</span><br><span class="line">        variable += addNumber</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> incrementor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>外层的 makeIncrementor 的返回里也需要在参数类型前面明确指出修饰词，以符合内部的定义，否则将无法编译通过</p>
<h1 id="字面转换量"><a href="#字面转换量" class="headerlink" title="字面转换量"></a>字面转换量</h1><p>Swift 提供了一组非常有意思的接口，用来将字面量转换为特定类型</p>
<p>开发中，经常可能用到的有：</p>
<p>ArrayLiteralConvertible<br>BooleanLiteralConvertible<br>DictionaryLiteralConvertible<br>FloatLiteralConvertible<br>NilLiteralConvertible<br>IntegerLiteralConvertible<br>StringLiteralConvertible</p>
<p>所有的字面量转换接口都定义了一个 typealias 和对应的 init 方法。拿 BooleanLiteralConvertible 举个例子</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">BooleanLiteralConvertible</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">BooleanLiteralType</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(booleanLiteral value: <span class="type">BooleanLiteralType</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>于是在我们需要自己实现一个字面量转换的时候，可以简单地只实现定义的 init 方法就行了。举个不太有实际意义的例子，我们想实现自己的 Bool 类型，可以这么做</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">MyBool</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> myTrue, myFalse</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MyBool</span>: <span class="title">BooleanLiteralConvertible</span> </span>&#123;</span><br><span class="line">    <span class="keyword">init</span>(booleanLiteral value: <span class="type">Bool</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span> = value ? myTrue : myFalse</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myTrue: <span class="type">MyBool</span> = <span class="literal">true</span></span><br><span class="line"><span class="keyword">let</span> myFalse: <span class="type">MyBool</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">myTrue.rawValue</span><br><span class="line">myFalse.rawValue</span><br></pre></td></tr></table></figure>

<p>BooleanLiteralType 大概是最简单的形式，如果我们深入一点，就会发现像是 StringLiteralConvertible 这样的接口会复杂一些，这个接口不仅类似上面布尔的情况，定义了 StringLiteralType 及接受其的初始化方法，这个接口还要求实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果通过 String 赋值生成 Person 对象的话，可以改写这个类：</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person1</span>: <span class="title">StringLiteralConvertible</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(name value: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = value</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>(stringLiteral value: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = value</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>(extendedGraphemeClusterLiteral value: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = value</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>(unicodeScalarLiteral value: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在所有的接口定义的 init 前面都加上了 required 关键字，这个类的子类都需要保证能够做类似的字面量转换，确保类型安全，但是会有很多重复代码，需要做一个修改加入，convenience</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person2</span>: <span class="title">StringLiteralConvertible</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(name value: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = value</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">convenience</span> <span class="keyword">init</span>(stringLiteral value: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(name: value)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">convenience</span> <span class="keyword">init</span>(extendedGraphemeClusterLiteral value: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(name: value)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">convenience</span> <span class="keyword">init</span>(unicodeScalarLiteral value: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(name: value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1: <span class="type">Person1</span> = <span class="string">"xiaoMing"</span></span><br><span class="line">p1.name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p: <span class="type">Person2</span> = <span class="string">"xiaoMing"</span></span><br><span class="line"><span class="built_in">print</span>(p.name)</span><br></pre></td></tr></table></figure>

<p>在上面的 Person 的例子中，我们没有像 MyBool 中做的那样，使用一个 extension 的方式来扩展类，使其可以使用字面量赋值，这是因为，在 extension 中，我们是不能定义 required 的初始化方法。 我们无法为现有的非 final 的 class 添加字面量转换</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Ammar</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://lizhaoloveit.cn/2016/06/23/Swifter%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(%E4%B8%80)/">http://lizhaoloveit.cn/2016/06/23/Swifter%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(%E4%B8%80)/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://lizhaoloveit.cn">Ammar's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Swift/">Swift    </a></div><div class="post_share"><div class="social-share" data-image="https://lizhaoloveit.cn/blogimages/blog/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-buttom"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lozad post-qr-code__img" data-src="/img/wechat.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lozad post-qr-code__img" data-src="/img/alipay.jpg"><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull-left"><a href="/2016/06/27/Swifter%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(%E4%BA%8C)/"><img class="prev_cover lozad" data-src="https://www.lizhaoloveit.cn/blogimages/blog/cover/1.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/2.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/3.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/4.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/5.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/6.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/7.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/8.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/9.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/10.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/11.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/12.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/13.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/14.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/15.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/16.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/17.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/18.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/19.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/20.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/21.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/22.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/23.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/24.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/25.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/26.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/27.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/28.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/29.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/31.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/32.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/33.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/34.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/35.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/36.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/37.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/38.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/39.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/40.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/41.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/42.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/43.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/44.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/45.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/46.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/47.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/48.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/49.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/50.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/51.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/52.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/53.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/54.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/55.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/56.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/57.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/58.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/59.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/60.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/62.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/63.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/64.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/65.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/66.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/67.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/68.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/69.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/70.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/71.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/72.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/73.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/74.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/75.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/76.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/77.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/78.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/79.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>Swifter 读书笔记(二)</span></div></a></div><div class="next-post pull-right"><a href="/2016/06/01/Swift-FMDB/"><img class="next_cover lozad" data-src="https://www.lizhaoloveit.cn/blogimages/blog/cover/1.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/2.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/3.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/4.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/5.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/6.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/7.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/8.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/9.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/10.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/11.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/12.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/13.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/14.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/15.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/16.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/17.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/18.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/19.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/20.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/21.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/22.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/23.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/24.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/25.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/26.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/27.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/28.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/29.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/31.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/32.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/33.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/34.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/35.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/36.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/37.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/38.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/39.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/40.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/41.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/42.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/43.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/44.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/45.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/46.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/47.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/48.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/49.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/50.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/51.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/52.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/53.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/54.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/55.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/56.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/57.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/58.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/59.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/60.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/62.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/63.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/64.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/65.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/66.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/67.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/68.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/69.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/70.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/71.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/72.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/73.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/74.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/75.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/76.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/77.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/78.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/79.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>Swift FMDB</span></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i> <span>评论</span></div><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'http://lizhaoloveit.cn/2016/06/23/Swifter%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(%E4%B8%80)/';
  this.page.identifier = '2016/06/23/Swifter读书笔记(一)/';
  this.page.title = 'Swifter 读书笔记(一)';
}
var d = document, s = d.createElement('script');
s.src = "https://" + 'lizhao' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script></div></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2014 - 2022 By Ammar</div><div class="icp"><a href="https://beian.miit.gov.cn/" target="_blank" rel="noopener"><span>浙ICP备19013619号-1</span></a></div><div class="bag"><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=33010502006128" target="_blank" rel="noopener"><img src="/img/beian.png"><span>浙公网安备 33010502006128号</span></a></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><section class="rightside" id="rightside"><i class="fa fa-book" id="readmode" title="阅读模式"> </i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换">繁</a><i class="far fa-moon nightshift" id="nightshift" title="夜间模式"></i></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script async src="/js/search/algolia.js"></script><script src="/js/nightshift.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()

</script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>