<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>Swifter 读书笔记(二) | Ammar's Blog</title><meta name="description" content="Swifter 读书笔记(二)"><meta name="keywords" content="Swift"><meta name="author" content="Ammar"><meta name="copyright" content="Ammar"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.11.1/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="http://lizhaoloveit.cn/2016/06/27/Swifter%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(%E4%BA%8C)/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="Swifter 读书笔记(二)"><meta name="twitter:description" content="Swifter 读书笔记(二)"><meta name="twitter:image" content="https://lizhaoloveit.cn/blogimages/blog/avatar.jpg"><meta property="og:type" content="article"><meta property="og:title" content="Swifter 读书笔记(二)"><meta property="og:url" content="http://lizhaoloveit.cn/2016/06/27/Swifter%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(%E4%BA%8C)/"><meta property="og:site_name" content="Ammar's Blog"><meta property="og:description" content="Swifter 读书笔记(二)"><meta property="og:image" content="https://lizhaoloveit.cn/blogimages/blog/avatar.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="prev" title="Swifter 读书笔记(三)" href="http://lizhaoloveit.cn/2016/06/29/Swifter%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(%E4%B8%89)/"><link rel="next" title="Swifter 读书笔记(一)" href="http://lizhaoloveit.cn/2016/06/23/Swifter%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(%E4%B8%80)/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?162506e75ffd64287398566b2f5738c8";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"VRMKRAV9AT","apiKey":"bd7157400046d0f02396708a501a3480","indexName":"lizhaoloveit","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"cookieDomain":"https://lizhaoloveit.cn/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: '添加书签',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天'

  
}</script><meta name="generator" content="Hexo 4.2.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#下标"><span class="toc-number">1.</span> <span class="toc-text">下标</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#方法嵌套"><span class="toc-number">2.</span> <span class="toc-text">方法嵌套</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#命名空间"><span class="toc-number">3.</span> <span class="toc-text">命名空间</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Any-和-AnyObject"><span class="toc-number">4.</span> <span class="toc-text">Any 和 AnyObject</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#typealias-和泛型接口"><span class="toc-number">5.</span> <span class="toc-text">typealias 和泛型接口</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#可变参数函数"><span class="toc-number">6.</span> <span class="toc-text">可变参数函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#初始化方法顺序"><span class="toc-number">7.</span> <span class="toc-text">初始化方法顺序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Designated-Convenience-和-Required"><span class="toc-number">8.</span> <span class="toc-text">Designated, Convenience 和 Required</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#protocol-组合"><span class="toc-number">9.</span> <span class="toc-text">protocol 组合</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#正则表达式"><span class="toc-number">10.</span> <span class="toc-text">正则表达式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#模式匹配"><span class="toc-number">11.</span> <span class="toc-text">模式匹配</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#…-和-lt"><span class="toc-number">12.</span> <span class="toc-text">… 和 ..&lt;</span></a></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://lizhaoloveit.cn/blogimages/blog/top_img.jpg)"><div id="page-header"><span class="pull-left"> <a class="blog_title" id="site-name" href="/">Ammar's Blog</a></span><div class="open toggle-menu pull-right"><div class="menu-icon-first"></div><div class="menu-icon-second"></div><div class="menu-icon-third"></div></div><span class="pull-right menus"><div class="mobile_author_icon"><img class="lozad" data-src="https://lizhaoloveit.cn/blogimages/blog/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'"><div class="mobile_author-info__description">微信号：aicjaish</div></div><hr><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a><a class="site-page" href="/comment/"><i class="fa-fw fa fa-coffee"></i><span> 留言</span></a><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title"><div class="posttitle">Swifter 读书笔记(二)</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2016-06-27<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2019-07-27</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Swift/">Swift</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Swift/Swift%E5%9F%BA%E7%A1%80/">Swift基础</a></span><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">5.6k</span><span class="post-meta__separator">|</span><span>阅读时长: 20 分钟</span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h1><p>我们通过下标访问字典得到的结果是一个 Optional 的值，由于无法限制下标访问的输入值，对于数组来说，越界了会崩掉，但是对于字典，查询不到是很正常的，在 Swift 中，就会返回 nil 告诉你没有要找的东西。</p>
<p>Swift 允许我们自定义下标，不仅包含了对自己写的类型进行下标自定义，也包括了对那些已经支持下标访问的类型进行扩展。在 Swift 的定义文件中，找到 Array 已经支持的下标访问类型：</p>
<p>subscript (index: Int) -&gt; T<br>subscript (subRange: Range<Int>) -&gt; Slice<T></p>
<p>共有两种，分别是接受单个 Int 类型和一个表示范围的 range<Int></p>
<p>这样其实就会有一个问题，我们很难一次性取出某几个特定位置的元素</p>
<p>其中一种做法就是接受数组为下标输入的读取方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="keyword">subscript</span>(input: [<span class="type">Int</span>]) -&gt; <span class="type">ArraySlice</span>&lt;<span class="type">Element</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> result = <span class="type">ArraySlice</span>&lt;<span class="type">Element</span>&gt;()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> input &#123;</span><br><span class="line">                <span class="built_in">assert</span>(i &lt; <span class="keyword">self</span>.<span class="built_in">count</span>, <span class="string">"Index out of range"</span>)</span><br><span class="line">                result.append(<span class="keyword">self</span>[i])</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (index, i) <span class="keyword">in</span> input.<span class="built_in">enumerate</span>() &#123;</span><br><span class="line">                <span class="built_in">assert</span>(i &lt; <span class="keyword">self</span>.<span class="built_in">count</span>, <span class="string">"Index out of range"</span>)</span><br><span class="line">                <span class="keyword">self</span>[i] = newValue[index]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">arr[[<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>]]</span><br><span class="line"></span><br><span class="line">arr[[<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>]] = [-<span class="number">1</span>, -<span class="number">3</span>, -<span class="number">4</span>]</span><br><span class="line">arr</span><br></pre></td></tr></table></figure>

<p>练习：虽然我们实现了下标为数组的版本，但是并不推荐使用这样的形式，如果阅读过 参数列表 一节的堵着也许会想为什么在这里我们不使用看起来更优雅的参数列表方式，就是 subscript(input: Int…)，存在一个问题，只有一个输入参数的时候，参数列表会导致和现有定义冲突，当然我们完全可以使用至少两个参数的参数列表形式避免这个冲突，定义形如： subcript(first: Int, second: Int, others: Int)的下标方法。</p>
<h1 id="方法嵌套"><a href="#方法嵌套" class="headerlink" title="方法嵌套"></a>方法嵌套</h1><p>方法终于成了  First-class citizen 也就是说，我们可以将方法当做变量或者参数使用了。更进一步，我们甚至可以在一个方法中定义新的方法，这给代码结构层次和访问级别的控制带来的心的选择。</p>
<p>在开发中，有很多情况下，由于一个方法主体太长，需要拆分成一个个小方法去调用，这些具体负责一个个小功能块的方法也许整个项目就调用这么一次，却不得不存在于整个类型的作用域中。虽然会标记为私有方法，但是事实上它们承担的任务往往和这个类型没有关系，只会在类型的某个方法中被用到。</p>
<p>甚至这些小方法也有可能很复杂，我们还想进一步将它分解成更小的某块，这样一来，本来应该是进深的结构，却被展平了。导致之后对代码的理解和维护上都很成问题。</p>
<p>在 Swift 中，我们对于这种情况有了很好的应对。我们可以在方法中定义其他方法。也就是说让方法嵌套起来。</p>
<p>举个例子，我们在写一个网络请求的类 Request 时，可能面临将请求的参数编码到 url 的任务，因为输入的参数可能包括单个的值，字典，数组，为了结构漂亮保持方法短小，我们可能将情况分开，写出这样的代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendQuery</span><span class="params">(<span class="keyword">var</span> url: String, key: String, value: AnyObject)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">appendQueryDictionary</span><span class="params">(<span class="keyword">var</span> url: String, key: String, value: [String: AnyObject])</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">appendQueryArray</span><span class="params">(<span class="keyword">var</span> url: String, key: String, value: [AnyObject])</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">appendQuerySingle</span><span class="params">(<span class="keyword">var</span> url: String, key: String, value: AnyObject)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> dictionary = value <span class="keyword">as</span>? [<span class="type">String</span>: <span class="type">AnyObject</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> appendQueryDictionary(url, key: key, value: dictionary)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> array = value <span class="keyword">as</span>? [<span class="type">AnyObject</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> appendQueryArray(url, key: key, value: array)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> appendQuerySingle(url, key: key, value: value)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事实上，前面三个方法都只会第一个方法中被调用，他们其实和 Request 没有直接的关系，所有将他们放到 appendQuery 中去会是一个更好的组织形式</p>
<p>虽然 Swift 提供了 public，internal，private 三种访问权限，有些方法我们完全不希望在其他地方被直接使用，最常见的就是在方法的模板中：我们一方面希望灵活地提供一个模板让使用者可以通过模板定制他们想要的方法，但是又不希望暴露太多实现细节，一个最简单的例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeIncrementor</span><span class="params">(addNumber: Int)</span></span> -&gt; ((<span class="keyword">inout</span> <span class="type">Int</span>) -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">incrementor</span><span class="params">(<span class="keyword">inout</span> variable: Int)</span></span> -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">        variable += addNumber;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> incrementor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h1><p>OC 一直以来的缺陷就是没有命名空间，在应用开发时，所有的代码和引用的静态库最终都会被编译到同一个域和二进制中。这样的后果是，一旦有重复的类名，就会导致编译失败和冲突。一般 OC 类型都会加上两到3个字母前缀，Apple 保留的 NS 和 UI，框架前缀等。</p>
<p>OC 社区大部分开发者也遵守了这个约定。一般会将自己名字的缩写作为前缀。但是前缀并不意味着不会冲突。</p>
<p>Swift 中，即使名字相同的类型，只要来自不同的命名空间，都是可以共存。Swift 的命名空间是基于 module 而不是在代码中显式指明，每个 module 代表 Swift 中的一个命名空间。同一个 target 里的类名还是不能相同，</p>
<p>在进行 app 开发时，默认添加到 app 的主 target 的内容都是处于同一个命名空间的，我们可以通过创建Cocoa Framework 的 target 方法新建一个 module，就可以在两个不同的 target 中添加相同的类型了</p>
<p>比如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyFramework.swift</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个文件存在于 MyFramework.framework 中</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">hello</span>() </span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"hello from framework"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// MyApp.swift</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个文件存在于 app 的主 target 中</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">hello</span>() </span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"hello from app"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用时，如果出现可能冲突的时候，需要在类型名前加上 module 名字：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyClass</span>.hello()</span><br><span class="line"><span class="comment">// hello from app</span></span><br><span class="line"></span><br><span class="line"><span class="type">MyFramework</span>.<span class="type">MyClass</span>.hello()</span><br><span class="line"><span class="comment">// hello from framework</span></span><br></pre></td></tr></table></figure>
<p>因为是在 app 的 target 中调用的，所以第一个 MyClass 会直接使用 app 中的版本，第二个调用我们指定了 MyFramework 中的版本</p>
<p>另一种策略是使用类型嵌套的方法指定访问的范围。常见做法是将名字重复的类型定义到不同的 struct 中，以此避免冲突。这样在不使用多个 module 的情况下也能取得隔离效果：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyClassContainer1</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">hello</span>() </span>&#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"hello from MyClassContainer1"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyClassContainer2</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">hello</span>() </span>&#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"hello from MyClassContainer2"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用时：</span></span><br><span class="line"></span><br><span class="line"><span class="type">MyClassContainer1</span>.<span class="type">MyClass</span>.hello()</span><br><span class="line"><span class="type">MyClassContainer2</span>.<span class="type">MyClass</span>.hello()</span><br></pre></td></tr></table></figure>

<h1 id="Any-和-AnyObject"><a href="#Any-和-AnyObject" class="headerlink" title="Any 和 AnyObject"></a>Any 和 AnyObject</h1><p>AnyObject 可以代表任何 class 类型的实例<br>Any 可以表示任意类型，甚至包括方法(func)类型</p>
<p>OC 中有一个 id 的概念，编译器不会对向声明为 id 的变量进行类型检查，它可以表示任意类的实例。</p>
<p>Swift 依然使用 Cocoa 框架进行 App 开发，为了与 Cocoa 架构协作，原来 id 的概念用 AnyObject 来进行替代。</p>
<p>Swift 中编译器不仅不对 AnyObject 实例的方法调用做出检查，甚至对 AnyObject 的所有方法调用都会返回 Optional 的结果。这在 OC 下是很正常的，返回 nil</p>
<p>在 Swift 下使用会比较麻烦。正确的做法是在使用时先确定 AnyObject 真正的类型并进行转换以后再进行调用。</p>
<p>原来 OC 中的某个 API 返回的是 id 的话，在 Swift 中都会被映射为 AnyObject?。我们依然最好这样写：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someMethod</span><span class="params">()</span></span> -&gt; <span class="type">AnyObject?</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> result	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> anyObject: <span class="type">AnyObject?</span> = <span class="type">SomeClass</span>.someMethod()</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> someInstance = anyObject <span class="keyword">as</span>? <span class="type">SomeRealClass</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 这里我们拿到了具体的 SomeRealClass 的实例</span></span><br><span class="line">	someInstance.funcOfSomeRealClass()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>protocol AnyObject {</p>
<p>}</p>
<p>所有的 class 都隐式地实现了这个借口，但是 AnyObject 只适用于 class 的原因。在 Swift 中，所有的基本类型，包括 Array 和 Dictionary 这些传统意义上会是 class 的东西，统统都是 struct 类型，并不能由 AnyObject 来表示，于是 Apple 提出一个 Any 的概念，除了 class，它还可以表示包括 struct 和 enum 在内的所有类型。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> swiftInt: <span class="type">Int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> swiftString: <span class="type">String</span> = <span class="string">"miao"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> array: [<span class="type">AnyObject</span>] = []</span><br><span class="line"></span><br><span class="line">array.append(swiftInt)</span><br><span class="line"></span><br><span class="line">array.append(swiftString)</span><br></pre></td></tr></table></figure>

<p>这里声明了一个 Int 和 String ，按理它们都应该只能被 Any 代表，而不能被 AnyObjcet 代表，但是这段代码运行时会通过编译。</p>
<p>此时如果我们打印一下 array，会发现里面的元素已经变成了 NSNumber 和 NSString 了，这里发生了一个自动转换。Swift 和 Cocoa 中这几个对应的类型是可以进行自动转换。因为我们显示声明了 AnyObject，编译器认为我们需要的是  Cocoa 类型，而非原生类型。帮我们进行了自动转换。</p>
<p>在上面的代码，如果去掉 import UIKit 就会编译错误了，而如果将类型变为 Any，就一切正确了。<br>这里需要说明的：如果只使用 Swift 类型，不转为 Cocoa 的话，对性能是有提升的。所以我们尽量使用原生类型。</p>
<p>如果我们代码里需要经常使用这两者。往往意味着代码在结构和设计上存在问题。最好避免依赖和使用这两者，尝试明确指出确定的类型。</p>
<h1 id="typealias-和泛型接口"><a href="#typealias-和泛型接口" class="headerlink" title="typealias 和泛型接口"></a>typealias 和泛型接口</h1><p>typealias 是用来为已经存在的类型重新定义名字，通过命名可以让代码变得更加清晰。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">distanceBetweenPoint</span><span class="params">(point: CGPoint, toPoint: CGPoint)</span></span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> dx = <span class="type">Double</span>(toPoint.x - point.x)</span><br><span class="line">    <span class="keyword">let</span> dy = <span class="type">Double</span>(toPoint.y - point.y)</span><br><span class="line">    <span class="keyword">return</span> sqrt(dx * dx + dy * dy)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> origin: <span class="type">CGPoint</span> = <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="number">0</span>)</span><br><span class="line"><span class="keyword">let</span> point: <span class="type">CGPoint</span> = <span class="type">CGPoint</span>(x: <span class="number">1</span>, y: <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">distance</span>: <span class="type">Double</span> =  distanceBetweenPoint(origin, toPoint: point)</span><br></pre></td></tr></table></figure>

<p>数学上和运行程序上都没有问题，但是阅读和维护，我们没有将数学抽象和实际问题结合起来。所以在阅读代码时，我们需要在大脑中额外进行转换：CGPoint 代表一个点，Double 是一个数字，代表两点之间的距离。</p>
<p>如果我们使用 typealias，就可以将这种转换直接写在代码里。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">Location</span> = <span class="type">CGPoint</span></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">Distance</span> = <span class="type">Double</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">distanceBetweenPoint</span><span class="params">(location: Location, toLocation: Location)</span></span> -&gt; <span class="type">Distance</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> dx = <span class="type">Distance</span>(location.x - toLocation.x)</span><br><span class="line">    <span class="keyword">let</span> dy = <span class="type">Distance</span>(location.y - toLocation.y)</span><br><span class="line">    <span class="keyword">return</span> sqrt(dx * dx + dy * dy)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> origin: <span class="type">Location</span> = <span class="type">Location</span>(x: <span class="number">0</span>, y: <span class="number">0</span>)</span><br><span class="line"><span class="keyword">let</span> point: <span class="type">Location</span> = <span class="type">Location</span>(x: <span class="number">1</span>, y: <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">distance</span>: <span class="type">Distance</span> = distanceBetweenPoint(origin, toLocation: point)</span><br></pre></td></tr></table></figure>

<p>对于普通类型，没有什么难点，但是涉及到泛型时，情况就会不太一样。typealias 是单一的，你必须指定将某个特定的类型通过 typealias 赋值为新的名字，而不能将整个泛型类型重命名，比如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&lt;<span class="title">T</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="keyword">typealias</span> <span class="type">Worker</span> = <span class="type">Person</span></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">Worker</span> = <span class="type">Person</span>&lt;<span class="type">T</span>&gt;</span><br><span class="line"><span class="keyword">typealias</span> <span class="type">Worker</span>&lt;<span class="type">T</span>&gt; = <span class="type">PerSon</span>&lt;<span class="type">T</span>&gt;</span><br></pre></td></tr></table></figure>

<p>但是一旦泛型类型确性得到暴涨后，就可以重命名了</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&lt;<span class="title">T</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="keyword">typealias</span> <span class="type">WorkId</span> = <span class="type">String</span></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">Worker</span> = <span class="type">Person</span>&lt;<span class="type">WorkId</span>&gt;</span><br></pre></td></tr></table></figure>

<p>Swift 中是没有泛型接口的，但是使用 typealias 我们可以在接口里自定义一个必须实现的别名，比如 GeneratorType 和 SequenceType 这两个接口中，Swift 都用到了这个技巧，来为接口确定一个使用的类似泛型的特性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">GeneratorType</span> </span>&#123;</span><br><span class="line">	<span class="keyword">typealias</span> <span class="type">Element</span></span><br><span class="line">	<span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">Self</span>.<span class="type">Element?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SequenceType</span> </span>&#123;</span><br><span class="line">	<span class="keyword">typealias</span> <span class="type">Generator</span>: <span class="type">GeneratorType</span></span><br><span class="line">	<span class="function"><span class="keyword">func</span> <span class="title">generate</span><span class="params">()</span></span> -&gt; <span class="type">Self</span>.<span class="type">Generator</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在实现这些接口时，我们不仅需要实现指定的方法，还要实现对应的 typealias，这时对接口适用范围的抽象和约束。</p>
<h1 id="可变参数函数"><a href="#可变参数函数" class="headerlink" title="可变参数函数"></a>可变参数函数</h1><p>可变参数，是指可以接受任意多个参数的函数。在 Swift 中，写一个可变参数的函数，只需要在声明参数时在类型后面加上…就可以了。下面就声明了一个接受可变参数的 Int 累加函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(input: Int...)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输入的 input 在函数体内被作为数组[Int]使用。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(input: Int...)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> input.<span class="built_in">reduce</span>(<span class="number">0</span>, combine: +)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(sum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>))</span><br></pre></td></tr></table></figure>

<p>在使用可变参数时，要注意的是可变参数只能作为方法中最后一个参数来使用，不能先声明一个可变参数，然后再声明其他参数。这很容易理解，因为编译器不知道输入的参数应该从哪里截取。在一个方法中，最多只能有一组可变参数的。</p>
<p>但是参数必须是同一种类型，要传入多个类型的参数时需要做一些变通。Swift 中一种解决方案是使用 Any 作为参数类型</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSString</span> </span>&#123;</span><br><span class="line">    <span class="keyword">convenience</span> <span class="keyword">init</span>(format: <span class="type">NSString</span>, <span class="number">_</span> args: <span class="type">CVarArgType</span>...)</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">"Tom"</span></span><br><span class="line"><span class="keyword">let</span> date = <span class="type">NSDate</span>()</span><br><span class="line"><span class="keyword">let</span> string = <span class="type">NSString</span>(format: <span class="string">"Hello %@. Date: %@"</span>, name, date)</span><br></pre></td></tr></table></figure>

<h1 id="初始化方法顺序"><a href="#初始化方法顺序" class="headerlink" title="初始化方法顺序"></a>初始化方法顺序</h1><p>与 OC 不同，Swift 的初始化方法需要保证类型的所有属性都被初始化，所以初始化方法的调用顺序就很有讲究，在某个类的子类中，初始化方法里的语句调用顺序并不是随意的，要保证当前子类实例的成员初始化完成后才能调用父类的初始化方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        name = <span class="string">"cat"</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tiger</span>: <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> power: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        power = <span class="number">10</span></span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">        name = <span class="string">"tiger"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般来说，子类的初始化顺序是：</p>
<ol>
<li>设置子类自己需要初始化的参数，power = 10</li>
<li>调用父类的响应的初始化方法，super.init()</li>
<li>对父类中的需要改变的成员进行设定，name = “tiger”</li>
</ol>
<p>第三步视情况而定，如果我们在子类中不需要对父类的成员作出改变，就不存在第三步。<br>这种情况，Swift 会自动的对父类的对应 init 方法进行调用，也就是说，第2步的 super.init()也是可以不用写，这种情况下初始化方法看起来就很简单：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        name = <span class="string">"cat"</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tiger</span>: <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> power: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        power = <span class="number">10</span></span><br><span class="line">        <span class="comment">// 如果我们不需要改变 name 的话</span></span><br><span class="line">        <span class="comment">// 虽然我们没有显式地对 super.init()进行调用</span></span><br><span class="line">        <span class="comment">// 不过由于这是初始化的最后了，Swift 替我们自动完成了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Designated-Convenience-和-Required"><a href="#Designated-Convenience-和-Required" class="headerlink" title="Designated, Convenience 和 Required"></a>Designated, Convenience 和 Required</h1><p>在 OC 中，init 方法是非常不安全的，没人能保证 init 只被调用一次，如果在初始化里使用属性设置的话，可能会造成各种问题。不应该在 init 中使用属性访问。但这不是编译器强制的。</p>
<p>Swift 有了超级严格的初始化方法，就是为了改进这一点，安全，Swift 有了超级严格的初始化方法，Swift 强化了 designated 初始化方法的地位。 Swift 初始化方式，保证了初始化后，所有成员变量均有初始值</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> numA: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">init</span>(num: <span class="type">Int</span>) &#123;</span><br><span class="line">        numA = num</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassB</span>: <span class="title">ClassA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> numB: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(num: <span class="type">Int</span>) &#123;</span><br><span class="line">        numB = num + <span class="number">1</span></span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(num: num)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 init 方法中，我们可以对 let 的实例常量进行赋值，这是初始化方法的重要特点。在 Swift 中，let 声明的值是不变量，无法被写入赋值，这对构建线程安全的 API 十分有用。而因为 Swift 的 init 只能被调用一次，因此在 init 中，我们可以为不变量进行辅助不会引起任何线程安全问题。</p>
<p>convenience 关键字的初始化方法，这类方法是 Swift 初始化方法中的”二等公民”，只作为补充和提供使用上的方便。所有 convenience 初始化方法都必须调用同一个类中的 designated 初始化设置。convenience 的初始化方法是不能被子类重写或者是从子类中以 super 的方式被调用的</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> numA: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">init</span>(num: <span class="type">Int</span>) &#123;</span><br><span class="line">        numA = num</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">convenience</span> <span class="keyword">init</span>(bigNum: <span class="type">Bool</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(num: bigNum ? <span class="number">10000</span> : <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassB</span>: <span class="title">ClassA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> numB: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(num: <span class="type">Int</span>) &#123;</span><br><span class="line">        numB = num + <span class="number">1</span></span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(num: num)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只需要在子类中实现重写父类的 convenience 方法所需的 init 方法，在子类中就可以使用父类的 convenience 初始化方法了。</p>
<p>在上面的代码中，我们在 ClassB 中实现了 init(num: Int)的重写。虽然没有实现 convenience 仍然可以用这个方法来完成子类初始化</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> anObj = <span class="type">ClassB</span>(bigNum: <span class="literal">true</span>)</span><br><span class="line"><span class="comment">// anObj.numA = 10000, anObj.numB = 10001</span></span><br></pre></td></tr></table></figure>

<p>系统会自动调用子类的初始化构造方法。</p>
<p>总结：</p>
<ol>
<li>初始化路径必须保证对象完全初始化，这可以通过调用本类型的 designated 初始化方法来得到保证</li>
<li>子类的 designated 初始化方法必须调用父类的 designated 方法，以保证父类也完成初始化。</li>
</ol>
<p>对于某些我们希望子类中一定实现的 designated 初始化方法，可以通过添加 required 关键字进行限制，强制子类对这个方法重写实现。</p>
<p>这样做最大的好处是，可以保证依赖于某个 designated 初始化方法的 convenience 一直可以被使用。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> numA: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>(num: <span class="type">Int</span>) &#123;</span><br><span class="line">        numA = num</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">convenience</span> <span class="keyword">init</span>(bigNum: <span class="type">Bool</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(num: bigNum ? <span class="number">10000</span>: <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassB</span>: <span class="title">ClassA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> numB: <span class="type">Int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>(num: <span class="type">Int</span>) &#123;</span><br><span class="line">        numB = num + <span class="number">1</span></span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(num: num)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="type">ClassB</span>(bigNum: <span class="literal">true</span>)</span><br><span class="line"><span class="built_in">print</span>(b.numB) <span class="comment">// 10001</span></span><br></pre></td></tr></table></figure>

<h1 id="protocol-组合"><a href="#protocol-组合" class="headerlink" title="protocol 组合"></a>protocol 组合</h1><p>Any 这个类型的定义十分奇怪，它是一个 protocol&lt;&gt;的同名类型</p>
<p>一般来说，标准写法是：protocol&lt;ProtocolA, ProtocolB, ProtocolC&gt;</p>
<p>但是 protocol&lt;&gt;是什么意思的？从语义上来说，这代表一个“需要实现空接口的接口” ，其实就是任意类型的意思</p>
<p>protocol 的组合相比新建一个接口的最大区别就是匿名性。</p>
<p>有时候可以借助这个特性写出更清晰的代码。</p>
<p>Swift 的类型组织是比较松散的，你的类型可以由不同的 extension 来定义实现不同的接口，Swift 也并没有要求他们在同一个文件中。这样，当一个类型实现了很多接口时，在使用该类我们很可能在不查询相关代码的情况下很难知道这个类型所实现的接口。</p>
<p>例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">KittenLike</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">meow</span><span class="params">()</span></span> -&gt; <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">DogLike</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">bark</span><span class="params">()</span></span> -&gt; <span class="type">String</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">TigerLike</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">aou</span><span class="params">()</span></span> -&gt; <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MysteryAnimal</span>: <span class="title">KittenLike</span>, <span class="title">DogLike</span>, <span class="title">TigerLike</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">meow</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"meow"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">bark</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"bark"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">aou</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"aou"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在如果重新定义一个叫做 PetLike 的接口，表明其实现 KittenLike 和 DogLike；如果稍后我们又想检查某种动物作为猫科动物的叫声的话，也许会创建新的 protocol</p>
<p>这时候一种比较好的写法是：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">PetLike</span> = <span class="class"><span class="keyword">protocol</span>&lt;<span class="title">KittenLike</span>, <span class="title">DogLike</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typealias</span> <span class="title">CatLike</span> = <span class="title">protocol</span>&lt;<span class="title">KittenLike</span>, <span class="title">TigerLike</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样既保持了可读性，也没有多定义不必要的新类型。<br>也可以直接匿名化：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SoundChecker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">checkPetTalking</span><span class="params">(pet: <span class="keyword">protocol</span>&lt;KittenLike, DogLike&gt;)</span></span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">checkCatTalking</span><span class="params">(cat: <span class="keyword">protocol</span>&lt;KittenLike, TigerLike&gt;)</span></span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的地方：</p>
<p>在 Swift 中，没有人限制或保证不同接口的方法不能重名，所以有可能出现的情况，比如 A 和 B 两个接口：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">bar</span><span class="params">()</span></span> -&gt; <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">bar</span><span class="params">()</span></span> -&gt; <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个接口中，bar()只有返回值的类型不同。我们如果有一个类型 Class 同时实现了 A 和 B，我们要怎么才能避免和解决调用冲突呢</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class</span>: <span class="title">A</span>, <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">bar</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">bar</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hi"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">“</span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">bar</span><span class="params">()</span></span> -&gt; <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">bar</span><span class="params">()</span></span> -&gt; <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line">两个接口中 bar() 只有返回值的类型不同。我们如果有一个类型 <span class="type">Class</span> 同时实现了 <span class="type">A</span> 和 <span class="type">B</span>，我们要怎么才能避免和解决调用冲突呢？</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class</span>: <span class="title">A</span>, <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">bar</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">bar</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hi"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance = <span class="type">Class</span>()</span><br><span class="line"><span class="keyword">let</span> num = (instance <span class="keyword">as</span> <span class="type">A</span>).bar()  <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">let</span> str = (instance <span class="keyword">as</span> <span class="type">B</span>).bar()  <span class="comment">// "Hi</span></span><br></pre></td></tr></table></figure>

<p>这样一来，对于 bar()，只要在调用前进行类型转换就可以了</p>
<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 封装：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正则工具类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegexTool</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单粒</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">let</span> instance = <span class="type">RegexTool</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">sharedInstance</span>() -&gt; <span class="title">RegexTool</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据正则 匹配字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isMatch</span><span class="params">(string: String, withRegexString regexString: String)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> regex = <span class="keyword">try</span> <span class="type">NSRegularExpression</span>(pattern: regexString, options: .<span class="type">CaseInsensitive</span>)</span><br><span class="line">        <span class="keyword">let</span> matches = regex.matchesInString(string, options: [], range: <span class="type">NSMakeRange</span>(<span class="number">0</span>, string.characters.<span class="built_in">count</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> matches.<span class="built_in">count</span> &gt; <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作符封装</span></span><br><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> =~ &#123;</span><br><span class="line">    <span class="keyword">associativity</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">precedence</span> <span class="number">130</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> =~<span class="params">(lhs: String, rhs: String)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> regexToolInstance = <span class="type">RegexTool</span>.sharedInstance()</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">try</span> regexToolInstance.isMatch(lhs, withRegexString: rhs)</span><br><span class="line">    &#125; <span class="keyword">catch</span> <span class="number">_</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mailPattern = <span class="string">"^([a-z0-9_\\.-]+)@([\\da-z\\.-]+)\\.([a-z\\.]&#123;2,6&#125;)$"</span></span><br><span class="line"><span class="keyword">let</span> maybeMailAddress = <span class="string">"onev@onevcat.com"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> regexToolInstance = <span class="type">RegexTool</span>.sharedInstance()</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> regexToolInstance.isMatch(maybeMailAddress, withRegexString: mailPattern)</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"CaseInsensitive"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者如下使用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> maybeMailAddress =~ mailPattern &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"有效的地址"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h1><p>虽然 Swift 中没有内置的正则表达式支持，但是和正则匹配有些相似的特性其实是内置于 Swift 中的，匹配模式。</p>
<p>相等匹配和范围匹配，在 Swift 里现在的模式匹配还很初级，使用~=来表示模式匹配操作符。看看 API：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> ~=&lt;T: Equatable&gt;<span class="params">(a: T, b: T)</span></span> -&gt; <span class="type">Bool</span> </span><br><span class="line"><span class="function"><span class="keyword">func</span> ~=&lt;T&gt;<span class="params">(lhs: _OptionalNilComparisonType, rhs: T?)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> ~=&lt;I : IntervalType&gt;<span class="params">(pattern: I, value: I.Bound)</span></span> -&gt; <span class="type">Bool</span></span><br></pre></td></tr></table></figure>
<p>从上至下载操作符左右两边分别接收可以判等的类型，可以与 nil 比较的类型，以及一个范围输入和某个特定值</p>
<p>Switch </p>
<ol>
<li>可以判等的类型的判断</li>
<li>对 Optional 的判断</li>
<li>对范围的判断</li>
</ol>
<p>Swift 的 switch 就是使用了~=操作符进行模式匹配，case 指定的模式作为左参数输入，等待匹配的被 switch 的元素作为操作符的右参数。按需求重载 ~= 操作符就可以使用 Switch 匹配正则表达式。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> ~=<span class="params">(pattern: NSRegularExpression, input: String)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> pattern.numberOfMatchesInString(input,</span><br><span class="line">        options: [],</span><br><span class="line">        range: <span class="type">NSRange</span>(location: <span class="number">0</span>, length: input.characters.<span class="built_in">count</span>)) &gt; <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">prefix</span> <span class="keyword">operator</span> ~/ &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">prefix</span> <span class="function"><span class="keyword">func</span> ~/<span class="params">(pattern: String)</span></span> -&gt; <span class="type">NSRegularExpression</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">NSRegularExpression</span>(pattern: pattern, options: <span class="literal">nil</span>, error: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> contact = (<span class="string">"http://onevcat.com"</span>, <span class="string">"onev@onevcat.com"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mailRegex: <span class="type">NSRegularExpression</span></span><br><span class="line"><span class="keyword">let</span> siteRegex: <span class="type">NSRegularExpression</span></span><br><span class="line"></span><br><span class="line">mailRegex = </span><br><span class="line">    <span class="keyword">try</span> ~/<span class="string">"^([a-z0-9_\\.-]+)@([\\da-z\\.-]+)\\.([a-z\\.]&#123;2,6&#125;)$"</span></span><br><span class="line">siteRegex = </span><br><span class="line">    <span class="keyword">try</span> ~/<span class="string">"^(https?:\\/\\/)?([\\da-z\\.-]+)\\.([a-z\\.]&#123;2,6&#125;)([\\/\\w \\.-]*)*\\/?$"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> contact &#123;</span><br><span class="line">    <span class="keyword">case</span> (siteRegex, mailRegex): <span class="built_in">print</span>(<span class="string">"同时拥有有效的网站和邮箱"</span>)</span><br><span class="line">    <span class="keyword">case</span> (<span class="number">_</span>, mailRegex): <span class="built_in">print</span>(<span class="string">"只拥有有效的邮箱"</span>)</span><br><span class="line">    <span class="keyword">case</span> (siteRegex, <span class="number">_</span>): <span class="built_in">print</span>(<span class="string">"只拥有有效的网站"</span>)</span><br><span class="line">    <span class="keyword">default</span>: <span class="built_in">print</span>(<span class="string">"嘛都没有"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// 同时拥有网站和邮箱</span></span><br></pre></td></tr></table></figure>

<h1 id="…-和-lt"><a href="#…-和-lt" class="headerlink" title="… 和 ..&lt;"></a>… 和 ..&lt;</h1></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Ammar</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://lizhaoloveit.cn/2016/06/27/Swifter%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(%E4%BA%8C)/">http://lizhaoloveit.cn/2016/06/27/Swifter%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(%E4%BA%8C)/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://lizhaoloveit.cn">Ammar's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Swift/">Swift    </a></div><div class="post_share"><div class="social-share" data-image="https://lizhaoloveit.cn/blogimages/blog/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-buttom"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lozad post-qr-code__img" data-src="/img/wechat.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lozad post-qr-code__img" data-src="/img/alipay.jpg"><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull-left"><a href="/2016/06/29/Swifter%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(%E4%B8%89)/"><img class="prev_cover lozad" data-src="https://www.lizhaoloveit.cn/blogimages/blog/cover/1.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/2.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/3.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/4.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/5.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/6.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/7.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/8.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/9.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/10.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/11.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/12.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/13.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/14.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/15.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/16.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/17.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/18.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/19.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/20.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/21.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/22.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/23.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/24.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/25.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/26.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/27.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/28.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/29.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/31.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/32.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/33.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/34.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/35.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/36.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/37.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/38.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/39.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/40.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/41.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/42.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/43.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/44.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/45.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/46.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/47.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/48.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/49.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/50.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/51.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/52.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/53.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/54.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/55.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/56.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/57.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/58.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/59.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/60.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/62.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/63.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/64.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/65.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/66.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/67.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/68.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/69.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/70.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/71.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/72.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/73.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/74.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/75.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/76.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/77.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/78.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/79.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>Swifter 读书笔记(三)</span></div></a></div><div class="next-post pull-right"><a href="/2016/06/23/Swifter%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(%E4%B8%80)/"><img class="next_cover lozad" data-src="https://www.lizhaoloveit.cn/blogimages/blog/cover/1.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/2.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/3.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/4.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/5.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/6.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/7.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/8.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/9.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/10.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/11.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/12.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/13.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/14.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/15.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/16.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/17.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/18.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/19.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/20.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/21.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/22.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/23.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/24.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/25.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/26.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/27.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/28.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/29.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/31.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/32.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/33.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/34.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/35.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/36.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/37.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/38.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/39.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/40.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/41.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/42.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/43.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/44.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/45.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/46.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/47.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/48.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/49.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/50.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/51.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/52.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/53.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/54.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/55.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/56.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/57.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/58.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/59.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/60.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/62.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/63.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/64.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/65.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/66.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/67.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/68.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/69.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/70.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/71.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/72.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/73.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/74.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/75.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/76.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/77.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/78.jpg,https://www.lizhaoloveit.cn/blogimages/blog/cover/79.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>Swifter 读书笔记(一)</span></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i> <span>评论</span></div><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'http://lizhaoloveit.cn/2016/06/27/Swifter%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(%E4%BA%8C)/';
  this.page.identifier = '2016/06/27/Swifter读书笔记(二)/';
  this.page.title = 'Swifter 读书笔记(二)';
}
var d = document, s = d.createElement('script');
s.src = "https://" + 'lizhao' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script></div></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2014 - 2022 By Ammar</div><div class="icp"><a href="https://beian.miit.gov.cn/" target="_blank" rel="noopener"><span>浙ICP备19013619号-1</span></a></div><div class="bag"><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=33010502006128" target="_blank" rel="noopener"><img src="/img/beian.png"><span>浙公网安备 33010502006128号</span></a></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><section class="rightside" id="rightside"><i class="fa fa-book" id="readmode" title="阅读模式"> </i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换">繁</a><i class="far fa-moon nightshift" id="nightshift" title="夜间模式"></i></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script async src="/js/search/algolia.js"></script><script src="/js/nightshift.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()

</script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>